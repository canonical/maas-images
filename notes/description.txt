From oleg.strikov Tue Feb  4 09:54:30 2014
Date: Tue, 4 Feb 2014 09:52:54
Subject: Basic support for new maas metadata format

Hi guys,

After a few days of work I came up with the initial (mostly PoC)
version of the tool responsible for pulling boot resources described
by a new metadata format.
In this mail I'd like to discuss some of the design decision that were
made and get as much of criticism as possible because it's much
simpler to fix most of the issues on this stage.

You can find all the source code here: https://pastebin.canonical.com/104209/
If you know any other way to share the code and make it commentable --
please let me know.

====================================
FINAL VERSION OF THE METADATA FORMAT
====================================

Here is how a typical metadata entry looks like:

{
 <...>
 "products": {
  "com.ubuntu.maas.repo2:boot:14.04:armhf:hwe": {
   "release": "trusty",
   "version": "14.04",
   "arch": "armhf",
   "versions": {
    "20140125": {
     "subarches": "slayton,highbank",
     "items": {
      "boot-kernel": {
       "path": "trusty/armhf/hwe-20140125/kernel",
       "md5": "b2d1236c286a3c0704224fe4105eca49",
       "size": 2097152,
       "ftype": "boot-kernel"
      },
      "boot-initrd": {
       "path": "trusty/armhf/hwe-20140125/initrd",
       "md5": "b2d1236c286a3c0704224fe4105eca49",
       "size": 2097152,
       "ftype": "boot-initrd"
      },
      "di-kernel": {
       "path": "trusty/armhf/hwe-20140125/di-kernel",
       "md5": "b2d1236c286a3c0704224fe4105eca49",
       "size": 2097152,
       "ftype": "di-kernel"
      },
      "di-initrd": {
       "path": "trusty/armhf/hwe-20140125/di-initrd",
       "md5": "b2d1236c286a3c0704224fe4105eca49",
       "size": 2097152,
       "ftype": "di-initrd"
      },
      "disk": {
       "path": "trusty/armhf/hwe-20140125/disk",
       "md5": "b2d1236c286a3c0704224fe4105eca49",
       "size": 2097152,
       "ftype": "disk"
      }
 <...>
}

Please note the following key aspects:

(1.1)
'subarches' field allows you to point out which subset of devices of
the speficic architecture can be booted by this boot resource;
metadata entry which describes generic (release) set of boot resources
will have the longest 'subarches' list
but some devices which are not enabled yet in the mainline will have
separate products which provide information on how to deploy these
machines;
this separate products will have pretty short 'subarches' list because
they are specific to one or two machine types;

(1.2)
'items' section is expandable; some products may provide more boot components
(kernel command line required to boot the machine, kernel device tree
(dtb) required to boot some ARM-based machines and others);

(1.3)
maas should be able to fetch boot resources (and their metadata) from
a set of independent sources

(1.4)
maas should be able to choose which boot resources to use for a
specific machine if multiple resources are available

=======================
MAAS CONFIGURATION FILE
=======================

We didn't decide yet which configuration file format to use. That's
why my PoC tool has pre-defined configuration options in the following
format:

    config['sources'] = [
        {
            'url': 'file:///home/strikov/maas-playground/boot-resources/repo1/',
            'mask': ['armhf/midway/*']
        },
        {
            'url': 'file:///home/strikov/maas-playground/boot-resources/repo2/',
            'mask': ['armhf/*/*']
        }
    ]

    config['sorting'] = ['sources_order','num_subarches(less)']
    config['storage'] = "/home/strikov/maas-playground/out/"

(2.1)
config['sources'] describes a list of sources which should be used to
pull the boot resources;
mask describes which boot resources we want to pull from a specific repository
('armhf/midway/*' mask means that we want to pull boot resources for
'midway' armhf machines for all distros available in the repo)

(2.2)
config['sorting'] describes how to choose the winner if multiple boot
resources are available for a specific machine;
configuration provided above instructs maas to give the boot resource
a higher priority if it came from a repo mentioned earlier in a repo
list;
if both resources came from the same repo then more specific (one
which has less supported subarches) boot resource wins

(2.3)
config['storage'] tells maas where to store all the pulled boot
resources (in production config it should be /var/lib/maas/<...>)

================
SCRIPT INTERNALS
================

(3.1)
Script needs to merge metadata from different sources and filter this
metadata according to the list of required arch/subarch/distro.
To simplify these operations script uses the following internal
representation of the metadata.
All the boot resources are represented by a hierarchy of dictionaries
which can be accessed the following way:
boot['armhf']['midway']['trusty'] -> [ {'product_name':<...>, <other
metadata field>}, {'product_name':<...>, <other metadata field>} ]

(3.2)
To generate this internal representation script uses RepoDumper class
derived from BasicMirrorWriter.
This object doesn't create any files in the filesystem and just
returns back the hierarchy of dictionaries described above.
Before merging hierarchies created from different metadata-sources
script filters these hierarchies according to repo-specific mask (e.g.
'armhf/midway/*').
Then all filtered hierarchies are merged into one.

(3.3)
As you can see in (3.1) boot[arch][subarch][distro] returns back a
list of boot resources available for this specific arch/subarch/distro
triplet.
We may sort this list to choose which boot resource to use. Sorting
procedure takes into account its configuration options passed in
config['sorting'].
After carring out this sorting procedure boot resources hierarchy
contains just a single entry (winner) for each arch/subarch/distro
triplet.
We basically know which product we need to pull for every
arch/subarch/distro triplet requested.

(3.4)
Using RepoWriter class derived from ObjectStoreMirrorWriter we pull
the products which were determined at (3.3).

(3.5)
To simplify interoperability with Provisioning Server script creates a
specific set of folders/files in the filesystem:
<...>/control/$arch/$subarch/$distro/{boot-kernel, boot-initrd,
di-kernel, di-initrd, disk} where every leaf is a symlink to a
specific binary object pulled from the repo.
By following this approach all the complexity is stored inside the
script not Provisioning Server.
Provision Server just pulls the requested object from a well-defined
hierarchy every time PXE request comes.

(3.6)
To create this hierarchy of symlinks we need to get additional
information at step (3.3) That's not enough to know which products we
want to pull.
We need to know for which subarch we want to use this product (product
can deploy many subarches but it won only for a single subarch).
To get this knowledge we 'reverse' our boot resource hierarchy to get
reverse[product_name] -> [subarch1, subarch2, subarch3] relation.
Then we pass this data structure to RepoWriter.
With this information available RepoWriter creates all the required
symlinks in the <...>/control/$arch/$subarch/$distro/<...> hierarchy

==============
OPEN QUESTIONS
==============

(4.1)
Do we want to have a separate configuration file for the tool
responsible for pulling boot resources?
Which file format to use for it?
Right now we have a separate configuration file
(/etc/maas/import_pxe_files) which utilizes trivial <var>=<content>
data format

(4.2)
Do we want to use 'keep_items' feature of the simplestreams library to
keep local copy of boot resources even if they are not provided by the
repo.
If yes -- do I still need to implement remove_item()-like callbacks?

(4.3)
How do we want to represent 'kernel command line' configuration option
of the product.
The simplest way is to have a specific text file containing kernel
command line required.
With this way we can handle it the same way as other items.

Oleg
