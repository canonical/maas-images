This builds maas ephemeral images from daily builds of cloud images.
Ie, it creates stuff that goes on
  http://maas.ubuntu.com/images/ephemeral-v2/daily
from stuff on
  http://cloud-images.ubuntu.com/daily

== setup ==
  Run './system-setup' to set up the system.
  This will install necessary dependencies.

  the tools expect that the 'bin' dir is in $PATH.

    export PATH=$PWD/bin:$PATH

== building images ==
To run:
  meph2-cloudimg-sync out.d

  You can then add filters to the end, like 'release=trusty' or
  'arch=amd64'.  The resultant out.d/streams/v1/ will have information
  copied from maas.ubuntu.com for all other products, but will only
  create new content for products that match the provided filters.


To debug and use the fake 'maas-cloudimg2eph2', run like:
  env MAAS_CLOUDIMG2EPH2=fake-maas-cloudimg2eph2 meph2-cloudimg-sync out.d

  This will still download di-kernels and di-initramfs.

== forcing image build ==
If the maas ephemeral data is up to date with the latest cloud image daily
then meph2-cloudimg-sync will not do anything.  In order to force it to
do something, point it at out locally crafted ephemeral data that does
not contain that.

  orig_eurl=http://maas.ubuntu.com/images/ephemeral-v2/daily/streams/v1/index.json
  sstream-mirror --no-item-download $orig_eurl ./local-ephemeral-v2

  # remove the newest entry for your desired build
  vi ./local-ephemeral-v2/streams/v1/com.ubuntu.maas:daily:v2:download.json

  # point meph2-cloudimg-sync at the local data
  meph2-cloudimg-sync --target=./local-ephemeral-v2/streams/v1/*download.json out.d

== streams management ==
Building as above will create out.d that has *metadata* describing
everything that is in the source stream and also the things that were
just built.  data (images) will only be present for the newly built things.

So after building new data and metadata, you'll then insert the new data into
an existing stream.  This option (meph2-util insert) is additive only.


=== insert data ===
Given output of a meph2-cloudimg-sync command above in build-output.d
and local daily stream directory daily-stream.d you can add the new data
with:

  meph2-util insert build-output.d daily-stream.d

If you do not want to sign (create .gpg and .sjson files), then you will
have to use '--no-sign'.

You can use '--dry-run' to only report what would be done.

=== Promoting Builds ===
Promoting is done on a specific version of a product.
You promote a daily build to a released build with a given label.
Likely that label is 'release'.

   # list the product-ids and version are available for promotion
   $ sstream-query --output-format="%(product_name)s %(version_name)s" --max=1 \
      daily.d/streams/v1/index.json arch=i386 | sort -u
   com.ubuntu.maas.daily:v2:boot:12.04:i386:hwe-p 20140414
   com.ubuntu.maas.daily:v2:boot:12.04:i386:hwe-q 20140414
   com.ubuntu.maas.daily:v2:boot:12.04:i386:hwe-r 20140414
   com.ubuntu.maas.daily:v2:boot:12.04:i386:hwe-s 20140414
   com.ubuntu.maas.daily:v2:boot:13.10:i386:hwe-s 20140416
   com.ubuntu.maas.daily:v2:boot:14.04:i386:hwe-t 20140416.1

   # promote the listed version
   $ meph2-util promote --label=release \
        daily.d/streams/v1/index.json releases.d/ 20140414 \
        product_name=com.ubuntu.maas.daily:v2:boot:12.04:i386:hwe-q


== cleaning old images ==
Cleaning is done in 2 parts:
  * cleaning meta-data (removing entries from the products files)
  * finding orphans: identify which files in the tree are no longer referenced.
  * purging orphans: removing files that are known to have been orpaned for
                     a given amount of time (3 days).

=== cleaning meta-data ===

clean-md is the meph-util subcommand that allows you to keep only a given
number of builds.  For example, to keep the latest 3 versions of every
product in the meta-data, you would run:

  meph2-util clean-md --max=3 daily-sream.d/

This *only* modifies the meta-data, it does not delete files, use find-orphans
and reap-orphans for that.

There is a --dry-run and --no-sign arguments also.

=== finding orphans ===

finding orphans creates a json formated file that contains a entry for each
file that is no longer referenced, and a timestamp of "now" (when it was first
found to be orphaned).

Example usage:
 The following will populate my-orphans.json.  Subsequent runs will update
 my-orphans.json with any new items, but will not update first-orphaned
 timestamp.

  $ meph2-util find-orphans my-orphans.json ./daily/ ./daily/streams/v1/*.json

More complex usage:
 Its possible that 2 streams dirs could share a data directory, similar
 to the 'pool' concept of apt for debian packages.  For example, the following
 directory tree layout (note, 'path' elements would have 'data' in them in
 this example):

   daily/
     data -> ../data/
     streams/v1/index.json
     streams/v1/daily.json
   released/
     data -> ../data
     streams/v1/index.json
     streams/v1/released.json
   data/
     trusty/...
     utopic/...

 Then, we could run meph-util find-orphans with:

   $ meph2-util find-orphans my-orphans.json ./data/ \
       ./daily/streams/v1/index.json released/streams/v1/index.json

 That will look through files in data/ that are not referenced by path
 elements in either the daily/streams/v1/ or released/streams/v1/ files.

 There is no --dry-run for finding orphans as it is non-destructive.


=== cleaning / reaping orphans ===
Reaping orphans is what actually removes files.  There is a '--dry-run' to
indicate what would be done.
 
its usage is fairly simple.

  $ meph2-util reap-orphans --older 7d my-orphans.json ./data/

'--older' takes input like:
   Ni
 Where N is a number and i can be one of:
   d: days
   h: hours
   m: minutes
   s: seconds

The default is '3d'.
