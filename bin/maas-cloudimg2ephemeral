#!/bin/bash
#
# maas-cloudimg2ephemeral - update a cloud image to make it sufficient
#                           for use as a maas ephemeral image
#
# Copyright (C) 2011-2012 Canonical
#
# Authors:
#    Scott Moser <scott.moser@canonical.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

_APT_UPDATED=false
IMAGES_PPA_APT_KEY="-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: SKS 1.0.10

mI0ETxf8lwEEAMAqtJVUnlCVzjTOsohaE/M4mGHFl4Py1cuE9ryOgmTWje+6BrNjtWLSfTQJ
Kp1V6hViUoxPBck1qkZoAz7VU5nDuBWDybCsolliUX4zzTYNiDnPS74fs4CDUWx9qpl5Sdb6
7aygIid/mFXubhJnTPR6Bq9ptGmc0Ks6ttNs3WJ/ABEBAAG0IkxhdW5jaHBhZCBQUEEgZm9y
IE1hYVMgTWFpbnRhaW5lcnOIuAQTAQIAIgUCTxf8lwIbAwYLCQgHAwIGFQgCCQoLBBYCAwEC
HgECF4AACgkQXP8eqZPujMU2zQP/W9OCzaU7HvFrqEt6nHGej2PEanIunxo7J8D5OR+Yl578
FpRkHRgvcdQnGuZUpdBnOFatDDFME7ClN9qUrD1wDN1r9ip2luaKiO2cZOW4Uu5Z0n/3Qc6J
eh9TNspyDMuHVVZ5GiAk+GXgF1m7ps5lCnOCZK/pXUEEUOS8AWnt3sM=
=1RpZ
-----END PGP PUBLIC KEY BLOCK-----"
IMAGES_PPA_FILE="/etc/apt/sources.list.d/maas-ephemeral-images.list"
IMAGES_PPA_URL="http://ppa.launchpad.net/maas-maintainers/maas-ephemeral-images/ubuntu"

VERBOSITY=0
TOP_D="${0%/*}"

error() { echo "$@" 1>&2; }
errorp() { printf "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }
failp() { [ $# -eq 0 ] || errorp "$@"; exit 1; }

Usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] disk kpkg kernel initrd [manifest]

   Update the image 'disk', installing 'kpkg'
   copy out kernel and initramfs tothe kernel 'kernel' and initrd 'initrd'
   If manifest is given, a (dpkg --show) manifest will be written.
   
   Expects to receive in a cloudimg disk image with no partition
   table, and will update it for maas ephemeral use.

   options:
      -v | --verbose      increase verbosity
EOF
}

bad_Usage() { Usage 1>&2; [ $# -eq 0 ] || error "$@"; return; }

debug() {
    local level=${1}; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "$(date -R):" "${@}"
}

disable_services() {
    local dir="$1"
    cat > "$dir/usr/sbin/policy-rc.d" <<"EOF"
#!/bin/sh
while true; do
    case "$1" in
        -*) shift ;;
        makedev) exit 0 ;;
        x11-common) exit 0 ;;
        *) exit 101 ;;
    esac
done
EOF
    [ $? -eq 0 ] && chmod 755 "$dir/usr/sbin/policy-rc.d" ||
        { error "failed to write policy-rc.d"; return 1; }
}

undisable_services() {
    local dir="$1"
    rm -f "$dir/usr/sbin/policy-rc.d"
}

check_required_vars() {
    local req="" missing=""
    for req in "$@"; do
        [ -n "${!req}" ] || missing="${missing} ${req}"
    done
    missing=${missing# }
    _RET="$missing"
    [ -z "$_RET" ]
}

show_vars() {
    local var
    for var in "$@"; do
       printf "%s=%s\n" "$var" "${!var}"
    done
}

_apt_update() {
    if [ "${_APT_UPDATED}" != "true" ]; then
        log_change true "run apt-update${1:+ [$1]}."
        _apt update
        _APT_UPDATED=true
    fi
}

_apt() {
    local emd=$(which eatmydata 2>/dev/null || :)
    case "$1" in
        upgrade|dist-upgrade|install) _apt_update "$1";;
    esac
    debug 1 "$emd apt-get ${apt_opts} --quiet --assume-yes $*"
    $emd apt-get ${apt_opts} -q --assume-yes "$@" </dev/null;
}

log_change() {
    local change="$1"
    shift
    if $change; then
       echo "CHANGE:" "$@"
    else
       echo "NO_CHANGE:" "$@"
    fi
}

filter_installed_packages() {
    # write to stdout, a list of packages not installed locally
    local fmt='${Package} ${Version}\n'
    LC_ALL=C dpkg-query --show "--showformat=${fmt}" "$@" 2>&1 | awk '
        $0 ~ /[Nn]o packages/ {
            sub("[.]$","",$NF);
            pkgs[n]=$NF;
            n=n+1;
        }
        $2 == "" {
                pkgs[n]=$1;
                n=n+1;
        };
        END { for(p in pkgs) {printf("%s ",pkgs[p])}; printf("\n"); }' n=0
}

apply_updates_chrooted() {
    # FIXME: remove this after no longer necessary
    local required="" known=""
    local release="" arch="" VERBOSITY=${_VERBOSITY:-1}
    local ppa_clear=${PPA_CLEAR:-true} change="" dist_upgrade=${DIST_UPGRADE:-false}
    required="kpkg"
    known="apt_opts PPA_CLEAR VERBOSITY DIST_UPGRADE"

    export LC_ALL=C FLASH_KERNEL_SKIP=1
    export DEBIAN_FRONTEND=noninteractive

    check_required_vars ${required} ||
        { error "$FUNCNAME: missing required vars: $_RET"; return 1; }

    if [ "$VERBOSITY" -ge 1 ]; then
        show_vars $required $known 1>&2
    fi
    
    release=$(lsb_release -sc) ||
        { error "failed to get release"; return 1; }

    arch="$(dpkg --print-architecture)" ||
        { error "failed to get dpkg arch"; return 1; }

    change="images ppa for cloud-init and maas-enlist (LP: #1511482, 1515733)"
    if [ "$release" != "precise" ]; then
        # apt-add-repository failed when trying quantal amd64 with qemu-static.
        # so instead do this manually.
        log_change true "$change"
        debug 1 "configuring PPA at $IMAGES_PPA_URL"
        echo "deb $IMAGES_PPA_URL $release main" > "$IMAGES_PPA_FILE" ||
            { error "failed writing to $IMAGES_PPA_FILE"; return 1; }
        printf "%s\n" "$IMAGES_PPA_APT_KEY" | apt-key add - ||
            { error "apt-key add failed!"; return 1; }
    else
        log_change false "$change"
        debug 1 "not adding images ppa to release=$release"
    fi

    change="ensure mellanox mlx4_en gets loaded (LP: #1115710)"
    if [ "$release" = "precise" -a ! -f "/etc/modprobe.d/mlx4.conf" ]; then
        # packaged version would be mlx4.conf, to avoid conflict
        # we install a different file here.
        printf "%s\n%s; %s\n" \
            "# mlx4_core should load mlx4_en (LP: #1115710)." \
            "install mlx4_core /sbin/modprobe --ignore-install mlx4_core" \
            "/sbin/modprobe mlx4_en" \
            > "/etc/modprobe.d/mlx4.ephemeral.conf"
        log_change true "$change"
    else
        log_change false "$change"
    fi

    change="build-only: divert newaliases (LP: #1531299)"
    local newaliases_hack=false
    if [ "$cross" = "true" ] && [ -f /usr/bin/newaliases ]; then
        log_change true "$change"
        # work around LP: #1531299
        debug 1 "hacking around newaliases in cross root (LP: #1531299)"
        dpkg-divert --local --rename --add /usr/bin/newaliases
        ln -s /bin/true /usr/bin/newaliases
        newaliases_hack=true
    else
        log_change false "$change"
    fi

    local removes="^linux-.*"
    local arch_pkgs="" toremove="" removed="" installed=""
    local add_pkgs="" rel_pkgs="" kernel_pkg=""
    if [ "$kpkg" != "none" ]; then
        kernel_pkg="$kpkg"
    fi

    # additional packages that we have to add
    add_pkgs="cloud-initramfs-dyn-netconf open-iscsi overlayroot"

    # rel_pkgs: packages added only in some releases
    case "$release" in
        precise|quantal|raring|saucy|trusty|utopic|vivid)
            rel_pkgs="${rel_pkgs} maas-enlist";;
    esac

    case "$arch" in
        arm64|armhf) arch_pkgs="u-boot-tools";;
    esac

    toremove=$(set -f; set -o pipefail; set -e;
        rlist=""
        inst=$(dpkg-query --show)
        for r in $removes; do
            matches=$(printf "%s\n" "$inst" |
                      awk '$1 ~ pm { printf("%s ",$1); }' "pm=$r")
            rlist="$rlist $matches"
        done
      echo ${rlist}
    )
    [ $? -eq 0 ] || { error "failed getting list to remove"; return 1; }
      
    change="removing linux kernel packages."
    if [ -z "$toremove" ]; then
        error "nothing installed matched: $removes. nothing to remove"
        log_change false "$change"
    else
        debug 1 "removing: $toremove"
        ( set -f; _apt remove --purge $toremove ) ||
            { error "failed to remove $toremove"; return 1; }
        log_change true "$change [$toremove]"
    fi
    removed="$toremove"

    change="apt-get dist-upgrade"
    if [ "${dist_upgrade}" != "false" ]; then
        log_change true "$change"
        _apt dist-upgrade ||
            { error "failed apt-get dist-upgrade"; return 1; }
    else
        log_change false "$change"
    fi

    local missing="" pkgs="$arch_pkgs $kernel_pkg $add_pkgs $rel_pkgs"
    missing=$(filter_installed_packages $pkgs)
    change="install missing packages"
    if [ -n "$missing" ]; then
        log_change true "$change [$missing]"
        _apt install $missing || {
            error "failed installing $missing";
            return 1;
        }
    else
        log_change false "$change"
    fi
    installed="$missing"

    if ${ppa_clear} && [ -f "$IMAGES_PPA_FILE" ]; then
        debug 1 "disabling ppa in $IMAGES_PPA_FILE."
        sed -i "s,^,#," "$IMAGES_PPA_FILE" ||
            { error "failed to clear $IMAGES_PPA_FILE"; return 1; }
    fi

    change="remove dpkg foreign architectures"
    if dpkg --print-foreign-architectures | grep -q i386; then
        log_change true "$change"
        # precise used multiarch file
        dpkg --remove-architecture i386 >/dev/null 2>&1 ||
            rm /etc/dpkg/dpkg.cfg.d/multiarch
        dpkg --print-foreign-architectures | grep i386 &&
            { error "failed to remove i386 foreign arch"; return 1; }
        debug 1 "removed foreign arch i386"
    else
        log_change false "$change"
    fi

    change="autoremove"
    if [ -n "$removed" ]; then
        log_change true "$change [removed=$removed]"
        _apt autoremove ||
            { error "failed apt-get autoremove"; return 1; }
    else
        log_change false "$change"
    fi

    log_change true "apt-get clean"
    _apt clean ||
        { error "failed apt-get clean"; return 1; }

    if [ "$newaliases_hack" = "true" ]; then
        debug 1 "restoring newaliases"
        rm -f /usr/bin/newaliases
        dpkg-divert --local --rename --remove /usr/bin/newaliases
        ls -l /usr/bin/newaliases
    fi

    change="symlink ENI for cloud-initramfs-dyn-netconf (LP: #1534205)"
    local f=/etc/network/interfaces
    log_change true "$change"
    mv "$f" "$f.dist" && ln -sf ../../run/network/dynamic-interfaces "$f" ||
        { error "failed to link dynamic interfaces"; return 1; }

    change="update-initramfs"
    if [ "$kpkg" != "none" ]; then
        local k="" i=""
        for i in /boot/vmlinu?-*; do
            [ "${i%-virtual}" = "${i}" ] && k=${i};
        done
        ver=${k##*/vmlinu?-}
        log_change true "$change [$ver]"
        debug 1 "updating kernel version '$ver'"
        update-initramfs -u -k "$ver" ||
            { error "update-initramfs failed"; return 1; }

        cp /boot/initrd.img-$ver /tmp/initrd.img &&
            cp /boot/vmlinu?-$ver /tmp/kernel.img &&
            chmod ugo+r /tmp/kernel.img ||
            { error "failed to publish kernel files to /tmp/"; return 1; }
    else
        log_change false "$change"
        debug 1 "kernel package = 'none'. No kernels published."
    fi
    dpkg-query --show > /tmp/manifest ||
        { error "failed to publish manifest to /tmp/"; return 1; }

    return 0
}

apply_updates() {
    # apply_updates(dir, kernel_out, initramfs_out)
    # update directory given, and pull out kernel and initramfs
    # to given locations
    short_opts="a:hv"
    long_opts="arch:,fix-perms-ref:,help,verbose"
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return 1; }
    local debian_arch="" perms_ref="" qemu_arch=""

    while [ $# -ne 0 ]; do
        cur=${1}; next=${2};
        case "$cur" in
            -a|--arch) debian_arch="$next"; shift;;
               --fix-perms-ref) perms_ref="$next"; shift;;
            -h|--help) Usage ; exit 0;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1));;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 4 -o $# -eq 5 ] ||
        { bad_Usage "expected image, kernel, ramdisk [,manifest]"; return 1; }
    local dir=$1 kpkg=$2 kernel_out=$3 initrd_out=$4 manifest=$5
    local tab="    "

    disable_services "$dir" || return
    
    # we expect /etc/lsb-release to be shell syntax with DISTRIB_CODENAME
    local rel="" fout host_arch
    host_arch=$(uname -m)
    rel=$(. "$dir/etc/lsb-release" && echo "${DISTRIB_CODENAME}") &&
        [ -n "$rel" ] ||
        fail "failed to read DISTRIB_CODENAME from $dir/etc/lsb-release"

    if [ -z "$debian_arch" ]; then
        # not pretty, use 'file' to determine arch
        fout=$(file -L "$dir/bin/sh") ||
            { error "'file' on $dir/bin/sh failed"; return 1; }
        case "$fout" in
            *\ x86-64,*) debian_arch="amd64";;
            *\ 80386,*)   debian_arch="i386";;
            *\ ARM\ aarch64,*) debian_arch="arm64";;
            *\ ARM,*)   debian_arch="armhf";;
            *\ 64-bit\ PowerPC*) debian_arch="ppc64el";;
            *) fail "unknown arch for fileoutput: $fout"; return 1;;
        esac
    fi

    case "$debian_arch" in
        x86_64|amd64) qemu_arch="x86_64";;
        arm64) qemu_arch="aarch64";;
        arm*) qemu_arch="arm";;
        ppc64le) qemu_arch="ppc64";;
        *) qemu_arch="$debian_arch";;
    esac

    local cross=true
    case "$host_arch:$qemu_arch" in
        $host_arch:$host_arch) cross=false;;
        i?86:i386) cross=false;;
        x86_64:i386) cross=false;;
        ppc64le:ppc64el) cross=false;;
        aarm64:arm64) cross=false;;
        arm*:arm*) cross=false;;
    esac

    debug 1 "arch: $debian_arch rel: $rel host_arch: $host_arch"
    debug 1 "qemu_arch=$qemu_arch cross=$cross"
    if $cross; then
        local fmt="${QEMU_STATIC_FMT:-/usr/bin/qemu-%a-static}" exe=""
        exe=${fmt//%a/$qemu_arch}
        cp "$exe" "$dir/usr/bin/qemu-${qemu_arch}-static" || {
            error "failed to copy qemu-static [$exe] for ${qemu_arch}";
            error "install qemu-user-static or set QEMU_STATIC_FMT";
            return 1;
        }
        debug 1 "copied $exe into filesystem /usr/bin/qemu-${qemu_arch}-static"
    else
        debug 1 "no qemu-static needed to execute $debian_arch on ${host_arch}"
    fi

    local prox="" apt_opts=""
    out=$(apt-config shell prox Acquire::HTTP::Proxy) &&
        eval $out && [ -n "$prox" ] &&
        apt_opts="--option=Acquire::HTTP::Proxy=${prox}"

    apt_opts="${apt_opts} --option=Dpkg::Options::=--force-confold"
    [ -n "${apt_opts}" ] &&
        debug 1 "using apt options ${apt_opts} for install"

    local me=$(readlink -f "$0")

    cross=$cross apt_opts="$apt_opts" kpkg="$kpkg" _VERBOSITY="$VERBOSITY" \
        chroot "$dir" /bin/bash -s apply_updates_chrooted < "$me" ||
        { error "failed chroot and kernel install"; return 1; }
    [ $? -eq 0 ] || {
        error "failed to install packages or mkinitramfs in chroot";
        return 1;
    }

    [ -n "$perms_ref" ] &&
        chown "--reference=$perms_ref" \
            "$dir/tmp/kernel.img" "$dir/tmp/initrd.img" "$dir/tmp/manifest"

    if [ "$kpkg" != "none" ]; then
        mv "$dir/tmp/kernel.img" "$kernel_out" &&
            mv "$dir/tmp/initrd.img" "$initrd_out" ||
            { error "failed to copy kernels out"; return 1; }
    fi

    # LP: #1034116: disable rescuevol and overlayroot's diskcfg
    change="disable rescuevol (LP: #1034116)"
    if grep -q "^cloud-initramfs-rescuevol${tab}" "$dir/tmp/manifest"; then
        log_change true "$change"
        # if cloud-initramfs-resuevol is installed, disable it
        echo "# cloud-initramfs-rescuevol is disabled by ${0##*/}" \
            > "$dir/etc/rescuevol-ignore" ||
        { error "failed to disable rescuevol"; return 1; }
    else
        log_change false "$change"
    fi

    change="disable overlayroot via /etc/overlayroot.local.conf (LP: #1533822)"
    if grep -q "^overlayroot${tab}" "$dir/tmp/manifest"; then
        printf "%s\n%s\n%s\n" "# overlayroot_cfgdisk disabled by ${0##*/}" \
            "overlayroot_cfgdisk=disabled" "overlayroot=tmpfs" \
            > "$dir/etc/overlayroot.local.conf"
    fi

    if [ -n "$manifest" ]; then 
        mv "$dir/tmp/manifest" "$manifest" || fail "failed to move manifest"
    else
        rm "$dir/tmp/manifest" ||
            fail "failed to rm manifest"
    fi
    
    undisable_services "$dir"

    return 0
}

if [ "$1" = "apply_updates" ]; then
    "$@"
elif [ "$1" = "apply_updates_chrooted" ]; then
    "$@"
else
    short_opts="a:hv"
    long_opts="arch:,help,verbose,zero"
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; exit 1; }
    arch=""
    vargs=""
    zero=false

    while [ $# -ne 0 ]; do
        cur=${1}; next=${2};
        case "$cur" in
            -a|--arch) arch="$next"; shift;;
            -h|--help) Usage ; exit 0;;
            -v|--verbose) vargs="${vargs}v";;
               --zero) zero=true;;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 4 -o $# -eq 5 ] ||
        { bad_Usage "expected image, kernel, ramdisk [,manifest]"; exit 1; }

    img="$1"
    kpkg="$2"
    kernel="$3"
    initrd="$4"
    manifest="$5"

    sudo \
        mount-image-callback --sys --proc --system-resolvconf "$img" -- \
        "$0" apply_updates ${vargs:+-$vargs} "--fix-perms-ref=$img" \
            ${arch:+"--arch=$arch"} _MOUNTPOINT_ \
            "$kpkg" "$kernel" "$initrd" ${manifest:+"${manifest}"} ||
        fail "failed to apply updates to $img"

    if $zero; then
        # this is optional as it will only work on a raw image
        e2fsck -fy "$img" || { error "failed to e2fsck $img"; exit 1; }
        zerofree "$img" || { error "failed zerofree $img"; exit 1; }
    fi

    exit 0

fi
# vi: ts=4 expandtab
