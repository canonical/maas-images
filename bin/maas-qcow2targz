#!/bin/bash
#
# maas-qcowtargz - Take a qcow2 or qcow2.xz file from a given URL or
#                  file path and make it sufficient for use as a 
#                  MAAS installable image
#
# Copyright (C) 2015-2018 Canonical
#
# Authors:
#    Lee Trager <lee.trager@canonical.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

TEMP_D=""
command -v unshare-pidns >/dev/null 2>&1 || PATH="${0%/*}:$PATH"

error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }

_dl() {
    local url="$1" out="$2" ret=0
    local tmp="$out.$$"
    wget "$url" --progress=dot:mega -O "$tmp" && mv "$tmp" "$out" || {
        ret=$?
        error "Failed downloading to $out: $url"
        rm -f "$tmp"
    }
    return $ret
}

dl() {
    local url="$1" out="${2:-${1##*/}}"
    if [ -n "${CACHE_D}" ]; then
        local cfile="${CACHE_D}/${url##*/}"
        if [ ! -f "$cfile" ]; then
            _dl "$url" "$cfile" || return
        fi
        [ "$cfile" -ef "$out" ] && return
        cp "$cfile" "$out"
        return
    fi

    _dl "$url" "$out"
}

cleanup() { [ -d "${TEMP_D}" ] && rm -Rf "${TEMP_D}"; }

function usage() {
    echo "Usage $0 [options] <URL> <SHA256> <out file>"
    echo "Options:"
    echo "  --curtin-path   Path to any curtin files to include in the image."
    echo "  --packages       Any extra packages to install into the image."

}

short_opts="c:p:h"
long_opts="curtin-path:,packages:,help"

getopt_out=$(getopt --name "${##*/}" --options "${short_opts}" --long "${long_opts}" -- "$@")
if [ $? -ne 0 ]; then
    usage
    exit 1
fi

eval set -- "$getopt_out"
while true; do
    case "$1" in
        -c|--curtin-path)
            curtin_path=$2
            shift 2
            ;;
        -p|--packages)
            packages=$2
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        --)
            shift
            break
            ;;
    esac
done

if [ "$1" == "maasify" ]; then
    [ "$(id -u)" = "0" ] || { error "not root, sorry"; exit 1; }
    root_d=$2
    out=$3
    if [ -n "$curtin_path" ]; then
        mkdir -p "$root_d/curtin" ||
            { error "failed to create /curtin"; return 1; }
        cp -r "$curtin_path/"* "$root_d/curtin/" || {
            error "failed copying $CURTIN_PATH to $root_d/curtin";
            return 1;
        }
        chmod +x "$root_d/curtin/"* ||
            { error "failed chmod +x $root_d/curtin/*"; return 1; }
    fi

    # mirrorlist finds the fastest mirror by returning a list of URLs which
    # yum then uses to find the fastest connection. Our build system only has
    # white listed Internet access. Use baseurl instead as the domain is
    # static.
    cp "${root_d}/etc/yum.repos.d/CentOS-Base.repo" \
       "${root_d}/etc/yum.repos.d/CentOS-Base.repo.orig"
    sed -i 's|^mirrorlist=|#mirrorlist=|g' \
        "${root_d}/etc/yum.repos.d/CentOS-Base.repo"
    sed -i 's|#baseurl=|baseurl=|g' \
        "${root_d}/etc/yum.repos.d/CentOS-Base.repo"

    if [ -n "$packages" ]; then
        # We need working DNS to pull packages from the repo
        cp /etc/resolv.conf "${root_d}/etc/resolv.conf"
        for package in $(echo $packages | sed 's/,/ /g'); do
            LANG=C unshare-pidns chroot "$root_d" yum -y install $package || {
                error "failed to install $package"
                exit 1
            }
            # epel-release installs an additional repository. Use the baseurl
            # instead of the mirrorlist to prevent issues with our build
            # system.
            if [ "$package" == "epel-release" ]; then
                cp "${root_d}/etc/yum.repos.d/epel.repo" \
                   "${root_d}/etc/yum.repos.d/epel.repo.orig"
                sed -i 's|^metalink=|#metalink=|g' \
                    "${root_d}/etc/yum.repos.d/epel.repo"
                sed -i 's|^#baseurl=|baseurl=|g' \
                    "${root_d}/etc/yum.repos.d/epel.repo"
            fi
        done

        # Restore the original repo configuation files.
        mv -f "${root_d}/etc/yum.repos.d/CentOS-Base.repo.orig" \
           "${root_d}/etc/yum.repos.d/CentOS-Base.repo"
        mv -f "${root_d}/etc/yum.repos.d/epel.repo.orig" \
           "${root_d}/etc/yum.repos.d/epel.repo"

        # Don't ship with yum cache
        LANG=C unshare-pidns chroot "$root_d" yum clean all || {
                error "failed to clear yum cache"
                exit 1
            }
        # Upstream ships with DNS information in /etc/resolv.conf, ship a
        # clean version.
        rm "${root_d}/etc/resolv.conf"
        touch "${root_d}/etc/resolv.conf"
        chown root:root "${root_d}/etc/resolv.conf"
        chmod 644 "${root_d}/etc/resolv.conf"
    fi

    error "Taring up image contents... into $out"
    gzflag="--use-compress-program=gzip"
    if command -v pigz >/dev/null 2>&1; then
        gzflag="--use-compress-program=pigz"
    fi
    tar --directory "$root_d" --create --preserve-permissions \
        --one-file-system \
        --sparse --file "$out" $gzflag \
        --xattrs "--xattrs-include=*" . || {
        error "failed tar command"
        rm -f "$out"
        exit 1
    }
else
    if [ $# -ne 3 ]; then
        usage
        exit 1
    fi
    url=$1
    sha256=$2
    if [ "$(dirname $3)" == "." ]; then
        out="${PWD}/${3}"
    else
        out=$3
    fi

    error "final output will be in ${out}"

    mkdir -p $(dirname "$out")

    cache_d="${CACHE_D:-$PWD/cache}"
    [ -d "$cache_d" ] || mkdir -p "$cache_d" || fail "failed mkdir $cache_d"

    TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX")
    trap cleanup EXIT

    if [ -f "$url" ]; then
        img_path="$url"
    else
        img_path="${cache_d}/${url##*/}"
        if [ ! -f "${img_path}" ]; then
            dl "$url" "$img_path" ||
                fail "failed download $url"
        else
            error "using cached '${url##*/}' in ${cache_d}"
        fi

        # We were given a SHA512 instead of a SHA256
        if [ ${#sha256} -eq 128 ]; then
            error "Checking sha512sum for $img_path"
            sha512_out=$(sha512sum "$img_path") ||
                fail "failed: sha512sum $img_path"
            sha512_out=${sha512_out%  *}
            if [ "$sha512_out" != "$sha256" ]; then
                fail "Error: unexpected sha512 of $img_path $sha512_out != $sha256"
            fi
        else
            error "Checking sha256sum for $img_path"
            sha256_out=$(sha256sum "$img_path") ||
                fail "failed: sha256sum $img_path"
            sha256_out=${sha256_out%  *}
            if [ "$sha256_out" != "$sha256" ]; then
                fail "Error: unexpected sha256 of $img_path $sha256_out != $sha256"
            fi
        fi

        fout=$(LANG=C file "$img_path") ||
            fail "failed file $img_path"
        case "${fout#$img_path: }" in
            "XZ compressed data"*)
                new_img_path="${img_path%.xz}"
                if [ -f "$new_img_path" ]; then
                    error "using cached uncompressed '$new_img_path'"
                else
                    error "Decompressing XZ image..."
                    xzcat "$img_path" > "${new_img_path}" ||
                        { rm -f "$new_img_path"; fail "failed xzcat"; }
                fi
                img_path="${new_img_path}"
                ;;
        esac
    fi
    working_img="${TEMP_D}/${img_path##*/}"

    error "copying $img_path to $working_img"
    cp "$img_path" "$working_img" ||
        fail "failed copying image ${img_path} -> ${working_img}"

    cb_args="maasify _MOUNTPOINT_ $out"
    [ -n "$curtin_path" ] && cb_args="$cb_args --curtin-path $curtin_path"
    [ -n "$packages" ] && cb_args="$cb_args --packages $packages"
    sudo \
        CACHE_D="${cache_d}" \
        ${http_proxy:+"http_proxy=${http_proxy}"} \
        ${https_proxy:+"https_proxy=${https_proxy}"} \
        mount-image-callback --proc --dev "$working_img" -- \
        "$0" $cb_args

    error "wrote $out"
fi

# vi: ts=4 expandtab
