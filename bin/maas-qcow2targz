#!/bin/bash
#
# maas-qcowtargz - Take a qcow2 or qcow2.xz file from a given URL or
#                  file path and make it sufficient for use as a 
#                  MAAS installable image
#
# Copyright (C) 2015-2016 Canonical
#
# Authors:
#    Lee Trager <lee.trager@canonical.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

PYTHON_OAUTH_RPM_URL="https://kojipkgs.fedoraproject.org/packages/"\
"python-oauth/1.0.1/10.el7/noarch/python-oauth-1.0.1-10.el7.noarch.rpm"
TEMP_D=""

error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }

maasify() {
    local root_d="$1" out="$2" curtin_path="$3"

    if [ -n "$curtin_path" ]; then
        mkdir -p "$root_d/curtin" ||
            { error "failed to create /curtin"; return 1; }
        cp -r "$curtin_path/"* "$root_d/curtin/" || {
            error "failed copying $CURTIN_PATH to $root_d/curtin";
            return 1;
        }
        chmod +x "$root_d/curtin/"* ||
            { error "failed chmod +x $root_d/curtin/*"; return 1; }
    fi

    # CentOS 7 removed python-oauth which is required for cloud-init to
    # authenticate with the MAAS metadata service. Until cloud-init from CentOS
    # supports python-oauth2 we need to pull python-oauth from EPEL7-testing
    local fname="" url="$PYTHON_OAUTH_RPM_URL"
    if [ -f "$root_d/etc/os-release" ] &&
        grep -qc "centos:7" "$root_d/etc/os-release"; then
        error "CentOS 7 detected! Adding python-oauth for MAAS cloud-init..."
        fname="/tmp/${PYTHON_OAUTH_RPM_URL##*/}"
        dl "$url" "$root_d/$fname" &&
            LANG=C chroot "$root_d" rpm -ivh "$fname" &&
            rm "$root_d/$fname" || {
                error "failed dl and installation of $url"
                return 1
            }
    fi

    error "Taring up image contents... into $out"
    local gzflag="--use-compress-program=gzip"
    if command -v pigz >/dev/null 2>&1; then
        gzflag="--use-compress-program=pigz"
    fi
    tar --directory "$root_d" --create --preserve-permissions \
        --one-file-system \
        --sparse --file "$out" $gzflag \
        --xattrs "--xattrs-include=*" . || {
        error "failed tar command"
        rm -f "$out"
        return 1
    }
}

_dl() {
    local url="$1" out="$2" ret=0
    local tmp="$out.$$"
    wget "$url" --progress=dot:mega -O "$tmp" && mv "$tmp" "$out" || {
        ret=$?
        error "Failed downloading to $out: $url"
        rm -f "$tmp"
    }
    return $ret
}

dl() {
    local url="$1" out="${2:-${1##*/}}"
    if [ -n "${CACHE_D}" ]; then
        local cfile="${CACHE_D}/${url##*/}"
        if [ ! -f "$cfile" ]; then
            _dl "$url" "$cfile" || return
        fi
        [ "$cfile" -ef "$out" ] && return
        cp "$cfile" "$out"
        return
    fi
    _dl "$url" "$out"
}

cleanup() { [ -d "${TEMP_D}" ] && rm -Rf "${TEMP_D}"; }

if [ "$1" = "maasify" ]; then
    [ "$(id -u)" = "0" ] || { error "not root, sorry"; exit 1; }
    "$@"
elif [ $# -eq 3 ] || [ $# -eq 4 ]; then
    url=$1
    sha256=$2
    if [ "$(dirname $3)" == "." ]; then
        out="${PWD}/${3}"
    else
        out=$3
    fi
    curtin_path=$4
    error "final output will be in ${out}"

    mkdir -p $(dirname "$out")

    cache_d="${CACHE_D:-$PWD/cache}"
    [ -d "$cache_d" ] || mkdir -p "$cache_d" || fail "failed mkdir $cache_d"

    TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX")
    trap cleanup EXIT

    if [ -f "$url" ]; then
        img_path="$url"
    else
        img_path="${cache_d}/${url##*/}"
        if [ ! -f "${img_path}" ]; then
            dl "$url" "$img_path" ||
                fail "failed download $url"
        else
            error "using cached '${url##*/}' in ${cache_d}"
        fi

        error "Checking sha256sum for $img_path"
        sha256_out=$(sha256sum "$img_path") ||
            fail "failed: sha256sum $img_path"
        found=${sha256_out%  *}
        if [ "$found" != "$sha256" ]; then
            fail "Error: unexpected sha256 of $img_path $found != $sha256"
        fi

        fout=$(LANG=C file "$img_path") ||
            fail "failed file $img_path"
        case "${fout#$img_path: }" in
            "XZ compressed data"*)
                new_img_path="${img_path%.xz}"
                if [ -f "$new_img_path" ]; then
                    error "using cached uncompressed '$new_img_path'"
                else
                    error "Decompressing XZ image..."
                    xzcat "$img_path" > "${new_img_path}" ||
                        { rm -f "$new_img_path"; fail "failed xzcat"; }
                fi
                img_path="${new_img_path}"
                ;;
        esac
    fi
    working_img="${TEMP_D}/${img_path##*/}"

    error "copying $img_path to $working_img"
    cp "$img_path" "$working_img" ||
        fail "failed copying image ${img_path} -> ${working_img}"

    sudo \
        CACHE_D="${cache_d}" \
        ${http_proxy:+"http_proxy=${http_proxy}"} \
        ${https_proxy:+"https_proxy=${https_proxy}"} \
        mount-image-callback --proc "$working_img" -- \
        "$0" maasify _MOUNTPOINT_ "$out" ${curtin_path:+"${curtin_path}"}

    error "wrote $out"
else
    error "Usage: $0 <URL> <SHA256> <out file> [curtin file path]"
    exit 1
fi

# vi: ts=4 expandtab
