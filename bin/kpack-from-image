#!/bin/bash

VERBOSITY=0
TEMP_D=""
COPY_TYPES="auto overlay qcow2 cp none"

error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }

Usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] image kernel-package out-dir

  Install kernel-package into image and copy the generated kernel
  and initrd out into out-dir
    out-dir/
      kernel
      initrd
      dtb-<filename>.dtb # for each file in lib/firmare/<ver>/device-tree

  Requires sudo to invoke mount-image-callback.

  options:
     --kihelper PROG   invoke PROG with kernel and initrd
                      This allows re-packing (ie, mkimage the files)
                      PROG is invoked with 2 arguments:
                        kernel-path initrd-path
                      it will have in its environment:
                        ROOT: path to the mounted 'image'
                        VERSION_FLAVOR: a string like 3.13.0-29-generic 
    --copy mode       use 'mode' to copy. default: auto
                      one of: ${COPY_TYPES}
                      overlay can be used only with mount-image-callback support
EOF
}

bad_Usage() { Usage 1>&2; [ $# -eq 0 ] || error "$@"; return 1; }
cleanup() {
    [ -z "${TEMP_D}" -o ! -d "${TEMP_D}" ] || rm -Rf "${TEMP_D}"
}

debug() {
    local level=${1}; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "${@}"
}

kernel_from_mp() {
    # this is the unwrapped function that actually does everything
    # it essentially gets called by mount-image-callback.
    local short_opts="hv"
    local long_opts="chown-to:,help,kihelper:,chown-to:,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local cur="" next=""
    local output="" copy=true chown_to="" gid="" uid="" kihelper=""
    local skip_update=${KPACK_SKIP_APT_UPDATE:-false}

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
               --chown-to) chown_to=$next; shift;;
            -h|--help) Usage ; exit 0;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1));;
               --kihelper) kihelper="$next"; shift;;
               --skip-update) skip_update=true;;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 3 ] ||
        { bad_Usage "expected 3 args, got $# [$*]"; return; }
    local mp="$1" kpkg="$2" outd="$3"

    local me="" myd=""
    me=$(readlink -f "$0") && myd="${me%/*}" ||
        { error "couldn't figure out full path to $0"; return 1; }
        
    if [ -n "$kihelper" ]; then
        if ! command -v "$kihelper" >/dev/null 2>&1 ; then
            [ -x "$myd/$kihelper" ] ||
                { error "failed to find kihelper"; return 1; }
            kihelper="$myd/$kihelper"
        fi
    fi
    [ -d "$outd" ] || mkdir -p "$outd" ||
        { error "failed mkdir $outd"; return 1; }

    local ch_outd="/tmp/output"
    KPACK_SKIP_APT_UPDATE=$skip_update CHROOTED_VERBOSITY=$VERBOSITY \
        chroot "$mp" /bin/bash -s chrooted "$kpkg" "$ch_outd" < "$me" ||
        { error "failed chroot and kernel install"; return 1; }

    if [ -n "$kihelper" ]; then
        local verflav=""
        read verflav < "$mp/$ch_outd/verflav"
        debug 1 "using $kihelper verflav='$verflav'"
        ROOT="$mp" VERSION_FLAVOR="$verflav" "$kihelper" \
            "$mp/${ch_outd}/kernel" "$mp/${ch_outd}/initrd" ||
        { error "$kihelper failed"; return 1; }
    fi

    if [ -n "$chown_to" ]; then
        ( cd "$mp/$ch_outd" && chown "$chown_to" * ) || {
            error "failed chown $mp/$ch_outd/*";
            return 1;
        }
    fi

    mv "$mp/$ch_outd/"* "$outd" ||
        { error "failed move files from chrooted outdi '$ch_outd'"; return 1; }

}

config_addl_modules() {
    local root="${1:-/}" fname=""
    fname="${root%/}/etc/initramfs-tools/hooks/kpack_extra"
    cat > "$fname" <<EOF
#!/bin/sh
. /usr/share/initramfs-tools/hook-functions

copy_modules_dir kernel/drivers/char/ipmi # LP: #1333271
manual_add_modules bcache # (LP: #1513176)
EOF
    [ $? -eq 0 ] || { error "failed writing $fname"; return 1; }
    chmod 755 "$fname" ||
        { error "failed setting execute on $fname"; return 1; }

    return 0
}

clean_local_udev_rules() {
    # in wily and later, /etc/udev/rules.d/*.rules will be copied
    # into the initramfs.  If there existed a '70-persistent-net.rules'
    # then those would be clearly wrong (mac addresses and naming for
    # the specific system that generated this).  Clean those out.
    local root="${1:-/}"
    rm -f "${root%/}/etc/udev/rules.d/70-persistent-net.rules"
}

chrooted() {
    # this is expected to run chrooted inside the root
    # installs all packages (arguments), writes kernel
    # and initramfs and 'verflav' to /tmp/ 
    VERBOSITY=${CHROOTED_VERBOSITY:-${VERBOSITY}}
    local pkgs="" kpkg="" copymods zzgrub emd="" out pkg
    local skip_update=${KPACK_SKIP_APT_UPDATE:-false}
    local verflav initrd kernel
    export LANG=C
    kpkg="$1"
    outd="$2"
    shift 2;
    pkgs=( "$kpkg" "$@" )

    mkdir -p "$outd" || { error "failed mkdir $outd"; return 1; }
    local stamp="$outd/stamp"
    touch "$stamp"

    $skip_update || apt-get update -q ||
        { error "apt-get update failed"; return 1; }

    copymods="cloud-initramfs-copymods"
    if [ -f /usr/share/initramfs-tools/hooks/copymods ]; then
        error "$copymods already installed"
        copymods=""
    else
        apt-cache show $copymods >/dev/null 2>&1 ||
            { error "copymods not available"; copymods=""; }
    fi

    zzgrub=/etc/kernel/postinst.d/zz-update-grub
    [ ! -x "$zzgrub" ] || chmod ugo-x $zzgrub

    which eatmydata >/dev/null 2>&1 && emd=eatmydata

    config_addl_modules / ||
        { error "failed configuring additional modules!"; return 1; }

    clean_local_udev_rules / ||
        { error "failed configuring additional modules!"; return 1; }

    DEBIAN_FRONTEND=noninteractive FLASH_KERNEL_SKIP=1 \
        $emd apt-get install --assume-yes --quiet \
            $copymods "${pkgs[@]}" </dev/null
    [ $? -eq 0 ] ||
        { error "failed install of $copymods $*"; return 1; }

    # here we look at all kernel files in /boot and get the package that
    # owns it.  if the package is the kernel that was supplied, then we
    # found it.  It supports 'kpkg' being a meta package by seeing
    # if kpkg would be removed if we uninstalled the kernel package.
    kernel=""
    for f in /boot/vmlin*; do
        [ -f "$f" ] || continue
        out=$(dpkg -S "$f")
        pkg=${out%%:*}
        [ "$pkg" = "$kpkg" ] && kernel="$f" && break
        if apt-get --dry-run remove $pkg | grep -q "Remv $kpkg "; then
            kernel="$f"
            break
        fi
    done
    [ -z "$kernel" ] && { error "no kernel found!" 1>&2; return 1; }
    verflav=${kernel#/boot/*-}
    initrd="/boot/initrd.img-$verflav"
    debug 2 "verflav is $verflav"

    if [ "$initrd" -ot "$stamp" ]; then
        debug 1 "initramfs did not update by package install. regenerating."
        update-initramfs -c -k "$verflav"
    fi

    [ -f "$initrd" ] || { error "no initrd for $verflav" 1>&2; return 1; }

    local name="" t="" outf=""
    for f in /boot/*-${verflav}; do
        t=$(basename "$f")
        case "$t" in
            vmlinu?*) name="kernel";;
            initrd.img*) name="initrd";;
            *)
                # name is the basename with -${verfla} removed
                name="${t%-${verflav}}"
        esac
        outf="$outd/$name"
        debug 2 "$f -> $outf"
        cp "$f" "$outf" && chmod ugo+r "$outf" ||
            { error "failed to copy '$name' from '$f'"; return 1; }
    done

    local path="/lib/firmware/$verflav/device-tree"
    if [ -d "$path" ]; then
        for f in $(find "$path" -type f -name "*.dtb"); do
            outf="$outd/dtb-${f##*/}"
            debug 2 "$f -> $outf"
            [ ! -f "$outf" ] || {
                error "basename collision over '${outf##*/}'"
                find "$path" -type f -name "${f##*/}" 1>&2
                return 1
            }
            cp "$f" "$outf" && chmod ugo+r "$outf" ||
                { error "failed to copy '$outf' from '$f'"; return 1; }
        done
    else
        debug 1 "dtb path '$path' did not exist. assume no dtb files"
    fi

    echo "$verflav" > "$outd/verflav" ||
        { error "failed to write verflavor"; return 1; }

    rm -f "$stamp"
}

main() {
    local short_opts="hv"
    local long_opts="help,kihelper:,copy:,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local cur="" next="" vflags=""
    local output="" copy=auto chown_to="" gid="" uid=""

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
            -h|--help) Usage ; exit 0;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1)); vflags="${vflags}v";;
               --kihelper) kihelper="$next"; shift;;
               --copy) copy=$next; shift;;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 3 ] ||
        { bad_Usage "expected 3 args, got $#"; return; }
    local img="$1" kpkg="$2" outd=${3}

    [ -z "$vflags" ] || vflags="-${vflags}"

    TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
        fail "failed to make tempdir"
    trap cleanup EXIT

    if [ "$copy" = "auto" ]; then
        if mount-image-callback --help | grep -q -- --overlay; then
            copy="overlay"
        elif command -v qemu-img >/dev/null 2>&1; then
            copy="qcow"
        else
            copy="cp"
        fi
    fi

    local imgfp myimg="${TEMP_D}/my.img" overlay_flags=""
    imgfp=$(readlink -f "$img") ||
        { error "failed to get full path to $img"; return 1; }
    debug 1 "copy mode = $copy"
    case "$copy" in
        none) ln -s "$imgfp" "$myimg" ||
            { error "failed link $imgfp -> $myimg"; return 1; };;
        cp) cp --sparse=always "$img" "$myimg" ||
            { error "failed cp '$img' to tempdir"; return 1; };;
        qcow) 
            qemu-img create -f qcow2 -b "$imgfp" "$myimg" ||
                { error "failed create qcow2 backed by $img"; return 1; };;
        overlay)
            overlay_flags="--overlay --read-only"
            ln -s "$imgfp" "$myimg" ||
            { error "failed link $imgfp -> $myimg"; return 1; };;
        *) error "bad copy type. one of: $COPY_TYPES"; return 1;;
    esac

    gid=$(id -g)
    uid=$(id -u)
    chown_to="$gid:$uid"

    local mic=""
    mic=$(which mount-image-callback) ||
        { error "mount-image-callback not in PATH"; return 1; }
    sudo \
        "KPACK_SKIP_APT_UPDATE=${KPACK_SKIP_APT_UPDATE:-false}" \
        "http_proxy=$http_proxy" PACKAGES="$kpkg" \
        "$mic" --sys --proc $overlay_flags \
            --system-resolvconf "$myimg" -- "$0" "kernel_from_mp" $vflags \
            _MOUNTPOINT_ "--chown-to=$chown_to" \
            ${kihelper:+"--kihelper=$kihelper"} \
            "$kpkg" "$outd" ||
    { error "failed"; return 1; }

    error "wrote to $outd"
    error "  " $(cd "$outd" && echo *)
    return
}

[ "$1" = "chrooted" ] && { shift; chrooted "$@"; exit; }
[ "$1" = "kernel_from_mp" ] && { shift; kernel_from_mp "$@"; exit; }
main "$@"
# vi: ts=4 expandtab
