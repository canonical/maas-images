#!/bin/bash

VERBOSITY=0
TEMP_D=""
COPY_TYPES="auto overlay qcow2 cp none"
UBUNTU_MIRROR=${UBUNTU_MIRROR:-"http://archive.ubuntu.com/ubuntu/"}
UBUNTU_MIRROR_PORTS=${UBUNTU_MIRROR_PORTS:-"http://ports.ubuntu.com/ubuntu-ports/"}
PROPOSED_ARCHIVE_FILE="/etc/apt/sources.list.d/proposed.list"
command -v unshare-pidns >/dev/null 2>&1 || PATH="${0%/*}:$PATH"

error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }

Usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] image kernel-package out-dir

  Install kernel-package into image and copy the generated kernel
  and initrd out into out-dir
    out-dir/
      kernel
      initrd
      dtb-<filename>.dtb # for each file in lib/firmare/<ver>/device-tree

  Requires sudo to invoke mount-image-callback.

  options:
     --kihelper PROG   invoke PROG with kernel and initrd
                      This allows re-packing (ie, mkimage the files)
                      PROG is invoked with 2 arguments:
                        kernel-path initrd-path
                      it will have in its environment:
                        ROOT: path to the mounted 'image'
                        VERSION_FLAVOR: a string like 3.13.0-29-generic 
    --copy mode       use 'mode' to copy. default: auto
                      one of: ${COPY_TYPES}
                      overlay can be used only with mount-image-callback support
EOF
}

bad_Usage() { Usage 1>&2; [ $# -eq 0 ] || error "$@"; return 1; }
cleanup() {
    [ -z "${TEMP_D}" -o ! -d "${TEMP_D}" ] || rm -Rf "${TEMP_D}"
}

debug() {
    local level=${1}; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "${@}"
}

disable_services() {
    local dir="$1"
    cat > "$dir/usr/sbin/policy-rc.d" <<"EOF"
#!/bin/sh
while true; do
    case "$1" in
        -*) shift ;;
        makedev) exit 0 ;;
        x11-common) exit 0 ;;
        *) exit 101 ;;
    esac
done
EOF
    [ $? -eq 0 ] && chmod 755 "$dir/usr/sbin/policy-rc.d" ||
        { error "failed to write policy-rc.d"; return 1; }
}

undisable_services() {
    local dir="$1"
    rm -f "$dir/usr/sbin/policy-rc.d"
}

_chroot() {
    local dir="$1"
    shift
    if [ "$dir" = "/" ]; then
        "$@"
    else
        chroot "$dir" "$@"
    fi
}

replace_newaliases() {
    local dir="$1"
    debug 1 "hacking around newaliases in root (LP: #1531299)"
    _chroot "$dir" dpkg-divert --local --rename --add /usr/bin/newaliases &&
        ln -s /bin/true "$dir/usr/bin/newaliases"
}

unreplace_newaliases() {
    local dir="$1" chroot_dir=""
    debug 1 "un-diverting newaliases in root"
    [ "$dir/bin/true" -ef "$dir/usr/bin/newaliases" ] || return 0
    rm -f "$dir/usr/bin/newaliases"
    _chroot "$dir" dpkg-divert --local --rename --remove /usr/bin/newaliases
}

kernel_from_mp() {
    # this is the unwrapped function that actually does everything
    # it essentially gets called by mount-image-callback.
    local short_opts="hv"
    local long_opts="chown-to:,help,kihelper:,proposed,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local cur="" next=""
    local output="" copy=true chown_to="" gid="" uid="" kihelper=""
    local proposed="false"
    local skip_update=${KPACK_SKIP_APT_UPDATE:-false}

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
               --chown-to) chown_to=$next; shift;;
            -h|--help) Usage ; exit 0;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1));;
               --kihelper) kihelper="$next"; shift;;
               --proposed) proposed=true;;
               --skip-update) skip_update=true;;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 3 ] ||
        { bad_Usage "expected 3 args, got $# [$*]"; return; }
    local mp="$1" kpkg="$2" outd="$3"

    local me="" myd=""
    me=$(readlink -f "$0") && myd="${me%/*}" ||
        { error "couldn't figure out full path to $0"; return 1; }
        
    if [ -n "$kihelper" ]; then
        if ! command -v "$kihelper" >/dev/null 2>&1 ; then
            [ -x "$myd/$kihelper" ] ||
                { error "failed to find kihelper"; return 1; }
            kihelper="$myd/$kihelper"
        fi
    fi
    if [ ! -d "$outd" ]; then
        mkdir -p "$outd" ||
            { error "failed mkdir $outd"; return 1; }
        if [ -n "$chown_to" ]; then
            chown "$chown_to" "$outd" || {
                error "failed chown output dir '$outd' to '$chown_to'";
                return 1;
            }
        fi
    fi

    local ch_outd="/tmp/output"
    KPACK_SKIP_APT_UPDATE=$skip_update CHROOTED_VERBOSITY=$VERBOSITY \
        PROPOSED=$proposed \
        unshare-pidns \
        chroot "$mp" /bin/bash -s chrooted "$kpkg" "$ch_outd" < "$me" ||
        { error "failed chroot and kernel install"; return 1; }

    if [ -n "$kihelper" ]; then
        local verflav=""
        read verflav < "$mp/$ch_outd/verflav"
        debug 1 "using $kihelper verflav='$verflav'"
        ROOT="$mp" VERSION_FLAVOR="$verflav" "$kihelper" \
            "$mp/${ch_outd}/kernel" "$mp/${ch_outd}/initrd" ||
        { error "$kihelper failed"; return 1; }
    fi

    if [ -n "$chown_to" ]; then
        ( cd "$mp/$ch_outd" && chown "$chown_to" * ) || {
            error "failed chown $mp/$ch_outd/*";
            return 1;
        }
    fi

    mv "$mp/$ch_outd/"* "$outd" ||
        { error "failed move files from chrooted outdi '$ch_outd'"; return 1; }

}

config_addl_modules() {
    local root="${1:-/}" rel="$2" fname=""
    fname="${root%/}/etc/initramfs-tools/hooks/kpack_extra"
    cat > "$fname" <<"EOF"
#!/bin/sh
. /usr/share/initramfs-tools/hook-functions

copy_modules_dir kernel/drivers/char/ipmi   # LP: #1333271
copy_modules_dir kernel/drivers/net/usb     # LP: #1552378
copy_modules_dir kernel/drivers/net/bonding # LP: #1835275
copy_modules_dir kernel/drivers/infiniband  # LP: #1835275
manual_add_modules bcache                   # LP: #1513176
manual_add_modules hpilo                    # LP: #1761639
case $(dpkg --print-architecture) in
    arm64)
        manual_add_modules i2c-thunderx # LP: #1702976
        ;;
esac
EOF
    [ $? -eq 0 ] || { error "failed writing $fname"; return 1; }

    case "$rel" in
        precise)
            echo "manual_add_modules squashfs # (LP: #1501834)" >> "$fname"
        ;;
        trusty|xenial)
        ;;
        *)
	    echo "copy_modules_dir kernel/drivers/md # (LP: #1813228)" >> "$fname"
        ;;
    esac

    chmod 755 "$fname" ||
        { error "failed setting execute on $fname"; return 1; }

    return 0
}

config_add_zfs() {
    # In order for curtin to use zfs when booted in ephemeral we need the
    # module included. This could also be achieved by zfs-initramfs package.
    # However, that would bring in /sbin/zfs.  We do not need use the 'zfs'
    # command or the kernel module *in* the initramfs, we just need the module
    # present so it can be used in install environment (LP: #1737592).
    local root="${1:-/}" rel="$2" fname=""
    fname="${root%/}/etc/initramfs-tools/hooks/kpack_zfs"
    case "$rel" in
        precise|trusty) return 0;;
    esac
    debug 1 "Will include zfs modules for release $rel."
    cat > "$fname" <<"EOF"
. /usr/share/initramfs-tools/hook-functions

manual_add_modules zfs # (LP: #1737592)
EOF
    [ $? -eq 0 ] || { error "failed writing to $fname for zfs"; return 1; }
    chmod 755 "$fname" || {
        error "failed adding execute to $fname for zfs";
        return 1;
    }
}

ensure_iscsi_initramfs_support() {
    local root="${1:-/}"
    local mfile="${root%/}/etc/iscsi/iscsi.initramfs"
    if [ ! -f "$mfile" ]; then
        mkdir -p "${mfile%/*}" && touch "$mfile" ||
        { error "failed to create iscsi.initramfs"; return 1; }
    fi
}

clean_local_udev_rules() {
    # in wily and later, /etc/udev/rules.d/*.rules will be copied
    # into the initramfs.  If there existed a '70-persistent-net.rules'
    # then those would be clearly wrong (mac addresses and naming for
    # the specific system that generated this).  Clean those out.
    local root="${1:-/}"
    rm -f "${root%/}/etc/udev/rules.d/70-persistent-net.rules"
}

insist_running_in_container() {
    local root="${1:-/}"
    ln -sf /bin/true "${root%/}/bin/running-in-container"

    local sdv="/usr/bin/systemd-detect-virt"
    local fpsdv="${root%/}${sdv}"
    if [ -x "${fpsdv}" ]; then
        # make 'systemd-detect-virt X' exit true for any value of
        # X in -c/--container -r/--chroot
        mv "${fpsdv}" "$fpsdv.real" && cat > "$fpsdv" <<"EOF"
#!/bin/sh
args=" $* "
hasarg() { [ "${args#* $1 }" != "$args" -o "${args#* $2 }" != "$args" ]; }
hasarg -q --quiet && msg=: || msg=echo
hasarg -c --container && { $msg "lxc"; exit 0; }
hasarg -r --chroot && { $msg "chroot"; exit 0; }
exec "$0.real" "$@"
EOF
        [ $? -eq 0 ] || { error "failed writing $sdv"; return 1; }
        chmod 755 "$fpsdv" || { error "failed chmod $fpsdv"; return 1; }
    fi
}

match_one_file() {
    # return 0 and write the file to stdout if the provided shell glob matches
    # only one file. return 1 if no files, 2 if more than one.
    local glob="$1"
    (set +f
        matched="" f=""
        n=0
        for f in $glob; do
            [ -f "$f" ] || continue
            matched="${matched} $f"
            n=$(($n+1))
        done
        matched="${matched# }"
        [ $n -eq 1 ] && echo "${matched}" && exit 0
        echo "$glob matched $n files: $matched"
        [ $n -eq 0 ] && exit 1
        exit 2
    )
}

vrun() {
    local vlvl="$1" msg="$2" 
    shift 2
    debug $vlvl "$msg: $*"
    "$@"
}

chrooted() {
    # this is expected to run chrooted inside the root
    # installs all packages (arguments), writes kernel
    # and initramfs and 'verflav' to /tmp/ 
    VERBOSITY=${CHROOTED_VERBOSITY:-${VERBOSITY}}
    local pkgs="" kpkg="" copymods zzgrub emd="" out pkg rel arch
    local skip_update=${KPACK_SKIP_APT_UPDATE:-false}
    local proposed=${PROPOSED:-false} proposed_lfile="${PROPOSED_ARCHIVE_FILE}"
    local verflav initrd kernel
    export LANG=C
    kpkg="$1"
    outd="$2"
    shift 2;
    pkgs=( "$kpkg" "$@" )

    mkdir -p "$outd" || { error "failed mkdir $outd"; return 1; }
    local stamp="$outd/stamp"
    touch "$stamp"

    rel=$(lsb_release -sc) ||
        { error "failed to read release"; return 1; }
    arch=$(dpkg --print-architecture) ||
        { error "failed to get architecture from dpkg"; return 1; }

    # add proposed if necessary
    if $proposed; then
        local mirror=""
        case "$arch" in
            i?86|amd64) mirror="${UBUNTU_MIRROR}";;
            *) mirror="${UBUNTU_MIRROR_PORTS}";;
        esac
        debug 1 "adding proposed ($mirror) to $proposed_lfile"
        echo "deb $mirror ${rel}-proposed main universe multiverse" \
            > "$proposed_lfile"
        $skip_update && 
            { skip_update=false; debug 1 "enabling update due to proposed"; }
    fi

    # trusty and wily do not have mdadm or lvm2 installed in the image
    # but we want those modules included (LP: #1519470)
    # the packages are expected to be in xenial already
    case "$rel" in
        precise|trusty|wily) pkgs=( lvm2 mdadm "${pkgs[@]}" );;
    esac

    $skip_update || apt-get update -q ||
        { error "apt-get update failed"; return 1; }

    copymods="cloud-initramfs-copymods"
    if [ -f /usr/share/initramfs-tools/hooks/copymods ]; then
        debug 1 "package '$copymods' already installed."
    else
        apt-cache show $copymods >/dev/null 2>&1 ||
            { error "package '$copymods' not available."; return 1; }
        debug 1 "adding package '$copymods'."
        pkgs=( "$copymods" "${pkgs[@]}" )
    fi

    local rooturl="cloud-initramfs-rooturl"
    if [ -f /usr/share/initramfs-tools/hooks/rooturl ]; then
        debug 1 "package '$rooturl' already installed."
    else
        if ! apt-cache show $rooturl >/dev/null 2>&1; then
            case "$rel" in
                precise)
                    debug 1 "package '$rooturl' not available on '$rel'";;
                *)
                    error "package '$rooturl' not available.";
                    return 1;;
            esac
        else
            debug 1 "adding package '$rooturl' (LP: #1688606)."
            pkgs=( "$rooturl" "${pkgs[@]}" )
        fi
    fi

    zzgrub=/etc/kernel/postinst.d/zz-update-grub
    [ ! -x "$zzgrub" ] || chmod ugo-x $zzgrub

    which eatmydata >/dev/null 2>&1 && emd=eatmydata

    config_addl_modules / "$rel" ||
        { error "failed configuring additional modules!"; return 1; }

    config_add_zfs / "$rel" ||
        { error "failed adding zfs"; return 1; }

    ensure_iscsi_initramfs_support / ||
        { error "failed to enable iscsi initramfs support"; return 1; }

    clean_local_udev_rules / ||
        { error "failed configuring additional modules!"; return 1; }

    insist_running_in_container / ||
        { error "failed to set running-in-container to true"; return 1; }

    disable_services / ||
        { error "failed to disable services before apt installs"; return 1; }

    replace_newaliases / ||
        { error "failed to replace newaliases"; return 1; }

    vrun 1 "installing packages" \
        env DEBIAN_FRONTEND=noninteractive FLASH_KERNEL_SKIP=1 \
        $emd apt-get install --assume-yes --quiet \
            "${pkgs[@]}" </dev/null
    [ $? -eq 0 ] ||
        { error "failed install of ${pkgs[*]}"; return 1; }

    undisable_services / ||
        { error "failed to re-enable services after apt installs"; return 1; }

    unreplace_newaliases / ||
        { error "failed to un-replace newaliases"; return 1; }

    $proposed && rm -f "$proposed_lfile"

    # here we look at all kernel files in /boot and get the package that
    # owns it.  if the package is the kernel that was supplied, then we
    # found it.  It supports 'kpkg' being a meta package by seeing
    # if kpkg would be removed if we uninstalled the kernel package.
    kernel=""
    for f in /boot/vmlin*; do
        [ -f "$f" ] || continue
        out=$(dpkg -S "$f" 2>/dev/null)
        pkg=${out%%:*}
        [ "$pkg" = "$kpkg" ] && kernel="$f" && break
        if apt-get --dry-run remove $pkg | grep -q "Remv $kpkg "; then
            kernel="$f"
            break
        fi
    done
    [ -z "$kernel" ] && { error "no kernel found!" 1>&2; return 1; }
    verflav=${kernel#/boot/*-}
    initrd="/boot/initrd.img-$verflav"
    debug 2 "verflav is $verflav"
    # LP: #1711203 - Prefer a signed kernel over an unsigned kernel. The signed
    # kernel is created by combining the key in /usr/lib/linux and the kernel
    # in /boot. As the kernel will not be in the dpkg database assume if it
    # exists it's what we want.
    local ret=0
    if out=$(match_one_file "$kernel*signed"); then
        debug 1 "Found and using signed kernel '$out' instead of $kernel."
        kernel="$out"
    else
        ret=$?
        if [ $ret -eq 1 ]; then
            debug 1 "No signed kernel, using un-signed kernel $kernel"
        else
            error "unexpected match. ret=$?: $out."
            return 1
        fi
    fi
    if [ "$initrd" -ot "$stamp" ]; then
        debug 1 "initramfs did not update by package install. regenerating."
        update-initramfs -c -k "$verflav"
    fi

    [ -f "$initrd" ] || { error "no initrd for $verflav" 1>&2; return 1; }

    local name="" t="" outf=""
    for f in /boot/*-${verflav}*; do
        # Skip unsigned kernel if a signed kernel is available.
        [ -f "$f"*.signed ] && continue
        t=$(basename "$f")
        case "$t" in
            vmlinu?*) name="kernel";;
            initrd.img*) name="initrd";;
            *)
                # name is the basename with -${verfla} removed
                name="${t%-${verflav}}"
        esac
        outf="$outd/$name"
        debug 2 "$f -> $outf"
        cp "$f" "$outf" && chmod ugo+r "$outf" ||
            { error "failed to copy '$name' from '$f'"; return 1; }
    done

    local path="/lib/firmware/$verflav/device-tree"
    if [ -d "$path" ]; then
        for f in $(find "$path" -type f -name "*.dtb"); do
            outf="$outd/dtb-${f##*/}"
            debug 2 "$f -> $outf"
            [ ! -f "$outf" ] || {
                error "basename collision over '${outf##*/}'"
                find "$path" -type f -name "${f##*/}" 1>&2
                return 1
            }
            cp "$f" "$outf" && chmod ugo+r "$outf" ||
                { error "failed to copy '$outf' from '$f'"; return 1; }
        done
    else
        debug 1 "dtb path '$path' did not exist. assume no dtb files"
    fi

    echo "$verflav" > "$outd/verflav" ||
        { error "failed to write verflavor"; return 1; }

    rm -f "$stamp"
}

main() {
    local short_opts="hv"
    local long_opts="help,kihelper:,copy:,proposed,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local cur="" next="" vflags=""
    local output="" copy=auto chown_to="" gid="" uid="" proposed_flag=""

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
            -h|--help) Usage ; exit 0;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1)); vflags="${vflags}v";;
               --kihelper) kihelper="$next"; shift;;
               --copy) copy=$next; shift;;
               --proposed) proposed_flag="--proposed";;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 3 ] ||
        { bad_Usage "expected 3 args, got $#"; return; }
    local img="$1" kpkg="$2" outd=${3}

    [ -z "$vflags" ] || vflags="-${vflags}"

    TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
        fail "failed to make tempdir"
    trap cleanup EXIT

    if [ "$copy" = "auto" ]; then
        if mount-image-callback --help | grep -q -- --overlay; then
            copy="overlay"
        elif command -v qemu-img >/dev/null 2>&1; then
            copy="qcow"
        else
            copy="cp"
        fi
    fi

    local imgfp myimg="${TEMP_D}/my.img" overlay_flags=""
    imgfp=$(readlink -f "$img") ||
        { error "failed to get full path to $img"; return 1; }
    debug 1 "copy mode = $copy"
    case "$copy" in
        none) ln -s "$imgfp" "$myimg" ||
            { error "failed link $imgfp -> $myimg"; return 1; };;
        cp) cp --sparse=always "$img" "$myimg" ||
            { error "failed cp '$img' to tempdir"; return 1; };;
        qcow) 
            qemu-img create -f qcow2 -b "$imgfp" "$myimg" ||
                { error "failed create qcow2 backed by $img"; return 1; };;
        overlay)
            overlay_flags="--overlay --read-only"
            ln -s "$imgfp" "$myimg" ||
            { error "failed link $imgfp -> $myimg"; return 1; };;
        *) error "bad copy type. one of: $COPY_TYPES"; return 1;;
    esac

    gid=$(id -g)
    uid=$(id -u)
    chown_to="$uid:$gid"

    local mic=""
    mic=$(which mount-image-callback) ||
        { error "mount-image-callback not in PATH"; return 1; }
    sudo \
        "KPACK_SKIP_APT_UPDATE=${KPACK_SKIP_APT_UPDATE:-false}" \
        "http_proxy=$http_proxy" PACKAGES="$kpkg" \
        UBUNTU_MIRROR=${UBUNTU_MIRROR} \
        UBUNTU_MIRROR_PORTS=${UBUNTU_MIRROR_PORTS} \
        "$mic" --sys --proc $overlay_flags \
            --system-resolvconf "$myimg" -- "$0" "kernel_from_mp" $vflags \
            _MOUNTPOINT_ "--chown-to=$chown_to" \
            ${kihelper:+"--kihelper=$kihelper"} ${proposed_flag} \
            "$kpkg" "$outd" ||
    { error "failed"; return 1; }

    error "wrote to $outd"
    error "  " $(cd "$outd" && echo *)
    return
}

[ "$1" = "chrooted" ] && { shift; chrooted "$@"; exit; }
[ "$1" = "kernel_from_mp" ] && { shift; kernel_from_mp "$@"; exit; }
main "$@"
# vi: ts=4 expandtab
