#!/usr/bin/python3

import argparse
import os
import sys

from meph2 import util

from simplestreams import filters
from simplestreams import mirrors
from simplestreams import util as sutil
from simplestreams import objectstores

CONTENT_ID = "com.ubuntu.maas.daily:v2:download"
PROD_PRE = "com.ubuntu.maas.daily:v2:boot"

DEF_KEYRING = "/usr/share/keyrings/ubuntu-cloudimage-keyring.gpg"

STREAMS_D = "streams/v1/"

LABELS = ('beta1', 'beta2', 'rc', 'release')

COMMON_ARGS = []
COMMON_FLAGS = {
    'dry-run': (('-n', '--dry-run'),
                {'help': 'only report what would be done',
                 'action': 'store_true', 'default': False}),
    'no-sign': (('-u', '--no-sign'),
                {'help': 'do not re-sign files',
                 'action': 'store_true', 'default': False}),
    'max': (('--max',),
            {'help': 'keep at most N items per product',
             'default': 1, 'type': int}),
    'orphan-data': (('orphan-data',), {'help': 'the orphan data file'}),
    'src': (('src',), {'help': 'the source streams directory'}),
    'target': (('target',), {'help': 'the target streams directory'}),
    'data_d': (('data_d',),
        {'help': 'the base data directory ("path"s are relative to this'}),
    'keyring': (('--keyring',),
        {'help': 'gpg keyring to check sjson', 'default': DEF_KEYRING}),
}

SUBCOMMANDS = {
    'insert': {
        'help': 'add new items from one stream into another',
        'opts': [
            COMMON_FLAGS['dry-run'], COMMON_FLAGS['no-sign'],
            COMMON_FLAGS['keyring'],
            COMMON_FLAGS['src'], COMMON_FLAGS['target'],
            ('filters', {'nargs': '*', 'default': []}),
        ]
    },
    'promote': {
        'help': 'promote a product/version from daily to release',
        'opts': [
            COMMON_FLAGS['dry-run'], COMMON_FLAGS['no-sign'],
            (('-l', '--label'),
             {'default': 'release', 'choices': LABELS,
              'help': 'the label to use'}),
            COMMON_FLAGS['src'], COMMON_FLAGS['target'],
            ('version', {'help': 'the version_id to promote.'}),
            ('filters', {'nargs': '+', 'default': []}),
        ]
    },
    'clean-md': {
        'help': 'clean streams metadata only to keep "max" items',
        'opts': [
            ('max', {'type': int}), ('target', {}),
            ('filters', {'nargs': '*', 'default': []}),
        ]
    },
    'find-orphans': {
        'help': 'find files in data_d not referenced in a "path"',
        'opts': [
            COMMON_FLAGS['orphan-data'], COMMON_FLAGS['data_d'],
            ('streams_dirs', {'nargs': '*', 'default': None}),
        ],
    },
    'reap-orphans': {
        'help': 'reap orphans listed in orphan-data from data_d',
        'opts': [
            COMMON_FLAGS['orphan-data'], COMMON_FLAGS['dry-run'],
            COMMON_FLAGS['data_d'],
        ],
    },
}


class BareMirrorWriter(mirrors.ObjectFilterMirror):
    # this does not do reference counting or .data/ storage
    # it stores data only in the streams
    def __init__(self, config, objectstore):
        super(BareMirrorWriter, self).__init__(config=config)
        self.store = objectstore
        self.config = config

    def products_data_path(content_id):
        return "streams/v1/" + content_id + ".json"

    def _noop(*args):
        return

    remove_item = _noop
    _inc_rc = _noop
    _dec_rc = _noop


def main_insert(args):
    (src_url, src_path) = sutil.path_from_mirror_url(args.src, None)
    filter_list = filters.get_filters(args.filters)

    def policy(content, path):
        if initial_path.endswith('sjson'):
            return sutil.read_signed(content, keyring=args.keyring)
        else:
            return content

    mirror_config = {'max_items': None, 'keep_items': True,
                     'filters': filter_list}
    smirror = mirrors.UrlMirrorReader(src_url, policy=policy)
    tstore = objectstores.FileStore(args.target)

    if args.dry_run:
        drmirror = mirrors.DryRunMirrorWriter(config=mirror_config,
                                              objectstore=tstore)
        for (pedigree, path, size) in drmirror.downloading:
            fmt = "{pedigree} {path}"
            sys.stderr.write(
                fmt.format(pedigree='/'.join(pedigree), path=path) + "\n")
        return 0

    tmirror = BareMirrorWriter(config=mirror_config, objectstore=tstore)
    tmirror.sync(smirror, src_path)

    md_d = os.path.join(args.target, "streams/v1/")
    util.create_index(md_d, files=None)

    if not args.no_sign:
        util.sign_stream_d(md_d)

    return 0
    

def main_promote(args):
    raise NotImplementedError()


def main_clean_md(args):
    raise NotImplementedError()


def main_find_orphans(args):
    raise NotImplementedError()


def main_reap_orphans(args):
    raise NotImplementedError()


def main():
    parser = argparse.ArgumentParser()

    # Top level args
    for (args, kwargs) in COMMON_ARGS:
        parser.add_argument(*args, **kwargs)

    subparsers = parser.add_subparsers()
    for subcmd in sorted(SUBCOMMANDS.keys()):
        val = SUBCOMMANDS[subcmd]
        sparser = subparsers.add_parser(subcmd, help=val['help'])
        mfuncname = 'main_' + subcmd.replace('-', '_')
        sparser.set_defaults(action=globals()[mfuncname])
        for (args, kwargs) in val['opts']:
            if isinstance(args, str):
                args = [args]
            sparser.add_argument(*args, **kwargs)

    args = parser.parse_args()
    if not getattr(args, 'action', None):
        # http://bugs.python.org/issue16308
        parser.print_help()
        return 1

    return args.action(args)


if __name__ == '__main__':
    sys.exit(main())

# vi: ts=4 expandtab syntax=python
