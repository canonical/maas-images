#!/bin/bash

VERBOSITY=1
TEMP_D=""

error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }

Usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] source-image output-image.gz

   convert 'source-image' into a ephemeral image and put
   output into output-image.gz.

   source-image can be url or file path that is either .tar.gz or .img.

   options:
         --no-gzip     do not gzip output image
    -k | --kernel K    keep/install the kernel package 'k' inside image
    -p | --krd-pack P  create a kernel / ramdisk pack
                       P is ',' delimited: kernel-name,kernel,ramdisk[,flags]
    -v | --verbose     increase verbosity

   Example:
     ${0##*/} --kernel=linux-generic \\
        --krd-pack=linux-generic,output/kernel,output/initrd \\
        trusty-server-cloudimg-armhf.tar.gz \\
        output/root-image.gz
EOF
}

bad_Usage() { Usage 1>&2; [ $# -eq 0 ] || error "$@"; return 1; }
cleanup() {
    [ -z "${TEMP_D}" -o ! -d "${TEMP_D}" ] || rm -Rf "${TEMP_D}"
}

ddebug() {
    local level="$1"; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "$(date -R):" "$@"
}

debug() {
    local level=${1}; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "${@}"
}

get_img_from_tar() {
    local img="$1" out="$2" tempd="$3"
    local mtmp=$(mktemp -d "${tempd}/img_from_tar.XXXXXX")
    tar -C "$mtmp" -Sxf "$img" ||
        { error "failed to extract $img"; return 1; }
    local f="" found=""
    for f in "${mtmp}/"*; do
        [ ! -f "$f" -o "${f%.img}" = "$f" ] && continue
        [ -z "$found" ] ||
            { error "multiple .img found in $img"; return 1; }
        found="$f"
    done
    [ -n "$found" ] || { error "no .img in $img"; return 1; }
    mv "$found" "$out" && rm -Rf "$mtmp"
}

get_img_file() {
    local fout="" input="$1" output="$2" tempd="$3"
    fout=$(LANG=C file "$input") || { error "failed: file $input"; return 1; }
    case "${fout#$input: }" in
        "gzip compressed"*)
            fout=$(zcat "$input" | file -)
            case "${fout#*: }" in
                POSIX\ tar*) get_img_from_tar "$input" "$output" "$tempd";;
                *) zcat -c "$input" > "$output";;
            esac
            ;;
        "POSIX tar"*)
            get_img_from_tar "$input" "$output" "$tempd";;
        *ext[234]\ filesystem*)
            ln -s "$(readlink -f "$input")" "$output";;
        *)
            # if the above failed (on trusty a .tar.gz file was reported
            # as a Minux file system) then try filename based heuristics
            case "$input" in
                *.tar.gz|*.tgz|*.tar) 
                    debug 1 "guessing content is tar archive [$fout]"
                    get_img_from_tar "$input" "$output" "$tempd";;
                *.gz)
                    debug 1 "guessing content is gzip [$fout]"
                    zcat -c "$input" > "$output";;
                *) 
                    error "WARN: unknown file '$input'. Assuming mountable image"
                    error "file output: $fout"
                    ln -s "$(readlink -f "$input")" "$output";;
            esac
    esac
}

ensure_file_d() {
    local f="" d=""
    for f in "$@"; do
        d=$(dirname "$f")
        mkdir -p "$d" || return
    done
    return 0
}

human2bytes() {
    # converts size suitable for input to resize2fs to bytes
    # s:512 byte sectors, K:kilobytes, M:megabytes, G:gigabytes
    # none: block size of the image
    local input=${1} defunit=${2:-1024}
    local unit count;
    case "$input" in
        *s) count=${input%s}; unit=512;;
        *K) count=${input%K}; unit=1024;;
        *M) count=${input%M}; unit=$((1024*1024));;
        *G) count=${input%G}; unit=$((1024*1024*1024));;
        *)  count=${input}  ; unit=${defunit};;
    esac
   _RET=$((${count}*${unit}))
}

resize_image() {
    # grow image 'img' by 'size' and return a string
    # suitable for restoring via restore_image
    local oversize=""
    case "$1" in
        --allow-oversize=*) oversize="${1#--allow-oversize}"; shift;;
        --allow-oversize) oversize="$2"; shift 2;;
    esac
    local img="$1" size="$2" ret="" tok=":"
    local oimgsize="" oblocks="" out="" blksize=""
    local tbytes="" minblocks=""
    out=$(ls -l "$img") && oimgsize=$(echo "$out" | awk '{print $5}') &&
        [ -n "$oimgsize" ] ||
        { error "failed to get size of $img"; return 1; }

    case "$size" in
        +*) human2bytes "${size#+}" ||
                { error "failed convert '${size#+}' to bytes"; return 1; }
            tbytes=$(($oimgsize+$_RET))
            ;;
        *) human2bytes "$size" ||
                { error "failed convert '$size' to bytes"; return 1; }
            tbytes=${_RET}
            ;;
    esac

    if [ -n "$oversize" ]; then
        human2bytes "$oversize" || {
            error "failed convert '$oversize' to bytes";
            return 1;
        }
    fi

    out=$(LC_ALL=C dumpe2fs "$img" 2>/dev/null) ||
        { error "failed 'dumpe2fs $img'"; return 1; }
    oblocks=$(printf "%s\n" "$out" |
        awk '$0 ~ /^Block count:/ { print $3 }') &&
        [ -n "$oblocks" ] || {
            error "failed to record blocks in $img"
            return
        }

    blksize=$(printf "%s\n" "$out" |
        awk '$0 ~ /^Block size:/ { print $3 }')

    out=$(LC_ALL=c resize2fs -P "$img" 2>/dev/null) ||
        { error "failed to get min image size"; return 1; }
    minblocks=$(printf "%s\n" "$out" | awk '$0 ~ /minimum/ { print $NF }')
    [ -n "$minblocks" ] ||
        { error "failed to get min blocks in '$img'"; return 1; }

    local tblocks=$(($tbytes/$blksize))
    if [ $tblocks -lt $minblocks ]; then
        error "target blocks '$tblocks' smaller than minblocks '$minblocks'"
        if [ -n "$oversize" ]; then
            tblocks=$(($tblocks+($oversize/$blksize)))
            error "WARN: '--allow-oversize=$oversize'. tblocks=$tblocks"
        else
            return 1
        fi
        tbytes=$(($tblocks*$blksize))
    fi

    ddebug 1 "targetting $tbytes bytes. fs is currently $oblocks * $blksize."
    ddebug 1 "resize to $tblocks blocks. minblocks=$minblocks."

    if [ "$oimgsize" -lt "$tbytes" ]; then
        truncate --size=$tbytes "$img" ||
            { error "failed to resize image to $tbytes"; return 1; }
    fi

    out=$(e2fsck -fy "$img" 2>&1) ||
        { error "failed to e2fsck -fy '$img'"; error "$out"; return 1; }

    out=$(resize2fs "$img" "$tblocks" 2>&1) ||
        { error "failed resize '$img'"; error "$out"; return 1; }

    if [ "$oimgsize" -gt "$tbytes" ]; then
        truncate --size=$tbytes "$img"
    fi

    out=$(e2fsck -fy "$img" 2>&1) ||
        { error "failed to e2fsck -fy '$img'"; error "$out"; return 1; }

    _RET="$oimgsize:$oblocks"
}

main() {
    local short_opts="a:hk:p:v"
    local long_opts="arch:,help,kernel:,krd-pack:,no-gzip,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local cur="" next="" output="" gzip=true kpkg=""
    local kpacks="" src_in="" src="" arch="" vflags=""
    local working_space="1024M" zero_img="true" fs_img_size="1400M"
    kpacks=( )

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
            -h|--help) Usage ; exit 0;;
            -a|--arch) arch="$next"; shift;;
            -k|--kernel) kpkg=$next; shift;;
            -p|--krd-pack) kpacks[${#kpacks[@]}]="$next"; shift;;
               --no-gzip) gzip=false;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1)); vflags="${vflags}v";;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 2 ] || { bad_Usage "must provide source and target"; return; }
    src_in="$1"
    output="$2"
    [ -z "$vflags" ] || vflags="-$vflags"

    PATH="$(dirname "$0"):$PATH"
    command -v "maas-cloudimg2ephemeral" >/dev/null 2>&1 ||
        { error "do not have maas-cloudimg2ephemeral in path"; return 1; }

    [ -z "$kpkg" ] && {
        error "no '--kernel' provided, choosing 'linux-generic'"
        kpkg="linux-generic"
    }

    TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
        { error "failed to make tempdir"; return 1; }
    trap cleanup EXIT

    if [ -f "$src_in" ]; then
        src="$src_in"
    else
        case "$src_in" in
            http://*|https://*|ftp://*)
                ddebug 1 "getting source $src_in"
                src="${TEMP_D}/${src_in##*/}"
                wget "$src_in" --dot-style=mega -O "$src" ||
                    { error "failed download $src_in"; return 1; }
                ;;
            file://*)
                [ -f "${src_in#file://}" ] ||
                    { error "$src_in: not a file"; return 1; }
                src="${src_in#file://}"
                ;;
            *) error "Unable to handle src: $src_in"; return 1;;
        esac
    fi

    # now src is either a .tar.gz file, or a .img file
    local imgfile="${TEMP_D}/root.img"
    ddebug 1 "getting .img from $src"
    get_img_file "$src" "$imgfile" "${TEMP_D}" ||
        { error "failed to get image file from $src"; return 1; }

    if [ "$src" -ef "$imgfile" ]; then
        rm -f "$imgfile"
        ddebug 1 "copying $src_in to $imgfile"
        cp --sparse=always "$src" "$imgfile" ||
            { error "failed to copy $src_in to temp"; return 1; }
    fi

    ensure_file_d "$output" ||
        { error "failed to create dir for $output"; return 1; }

    local restore_img_info=""
    if [ -n "$working_space" ]; then
        ddebug 1 "getting '$working_space' in $imgfile"
        resize_image "$imgfile" "+$working_space" ||
            { error "failed to grow $imgfile by $working_space"; return 1; }
        restore_img_info="$_RET"
    fi

    # now imgfile has the root filesystem image to adjust
    local pkout="${TEMP_D}/$kpkg-kernel" piout="${TEMP_D}/$kpkg-initrd"
    local manif="${TEMP_D}/manifest"
    ddebug 1 "starting maas-cloudimg2ephemeral"
    maas-cloudimg2ephemeral $vflags \
        ${arch:+"--arch=$arch"} "$imgfile" \
        "$kpkg" "$pkout" "$piout" "$manif" ||
        { error "failed to turn $imgfile to ephemeral"; return 1; }

    local i="" ckpkg="" ckout="" ciout="" subarch="" oifs="$IFS"
    ddebug 1 "starting kpacks: ${kpacks[*]}"
    for i in "${kpacks[@]}"; do
        IFS=","; set -- $i; IFS="$oifs"
        # tkout, tiout = target kernel out, target initrd out
        ckpkg="$1"; tkout="$2"; tiout="$3"
        shift 3
        flags=( "$@" )
        ckout="${TEMP_D}/$ckpkg-kernel"
        ciout="${TEMP_D}/$ckpkg-initrd"
        ddebug 1 "$(date -R): starting kpack-from-image for $ckpkg/${flags[*]}"
        KPACK_SKIP_APT_UPDATE=true kpack-from-image ${vflags} "$imgfile" \
            "$ckpkg" "$ckout" "$ciout" "${flags[@]}" ||
            { error "failed to get $ckpkg output"; return 1; }
        ensure_file_d "$tkout" "$tiout" ||
            { error "failed to make dirs for $tkout or $tiout"; return 1; }
        mv "$ckout" "$tkout" &&
            mv "$ciout" "$tiout" ||
            { error "failed copying files"; return 1; }
    done
    ddebug 1 "kpacks done"

    if [ -n "$fs_img_size" ]; then
        ddebug 1 "setting final image to $fs_img_size"
        resize_image "$imgfile" "$fs_img_size" || {
            error "failed to set '$imgfile' to '$fs_img_size'"
            return 1;
        }
    fi

    if $zero_img; then
        ddebug 1 "zeroing img"
        e2fsck -fy "$imgfile" || { error "failed to e2fsck $imgfile"; return 1; }
        zerofree "$imgfile" || { error "failed zerofree $imgfile"; return 1; }
    fi

    if $gzip; then
        ddebug 1 "gzipping image file"
        local stime=$SECONDS
        gzip -9 --rsyncable "$imgfile" &&
            mv --force "$imgfile.gz" "$output" ||
            { error "failed gzip"; return 1; }
        ddebug 1 "gzip took $(($SECONDS-$stime))s"
    else
        mv --force "$imgfile" "$output" ||
            { error "failed move to $output"; return 1; }
    fi
    ddebug 1 "finished"
    return 0
}

main "$@"
# vi: ts=4 expandtab
