#!/bin/bash

VERBOSITY=0
TEMP_D=""

error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }

Usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] source-image output-image.gz

   convert 'source-image' into a ephemeral image and put
   output into output-image.gz.

   source-image can be url or file path that is either .tar.gz or .img.

   options:
         --no-gzip     do not gzip output image
    -k | --kernel K    keep/install the kernel package 'k' inside image
    -p | --krd-pack P  create a kernel / ramdisk pack
                       P is ',' delimited: kernel-name,kernel,ramdisk[,flags]
    -v | --verbose     increase verbosity

   Example:
     ${0##*/} --kernel=linux-generic \\
        --krd-pack=linux-generic,output/kernel,output/initrd \\
        trusty-server-cloudimg-armhf.tar.gz \\
        output/root-image.gz
EOF
}

bad_Usage() { Usage 1>&2; [ $# -eq 0 ] || error "$@"; return 1; }
cleanup() {
    [ -z "${TEMP_D}" -o ! -d "${TEMP_D}" ] || rm -Rf "${TEMP_D}"
}

debug() {
    local level=${1}; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "${@}"
}

get_img_from_tar() {
    local img="$1" out="$2" tempd="$3"
    local mtmp=$(mktemp -d "${tempd}/img_from_tar.XXXXXX")
    tar -C "$mtmp" -Sxf "$img" ||
        { error "failed to extract $img"; return 1; }
    local f="" found=""
    for f in "${mtmp}/"*; do
        [ ! -f "$f" -o "${f%.img}" = "$f" ] && continue
        [ -z "$found" ] ||
            { error "multiple .img found in $img"; return 1; }
        found="$f"
    done
    [ -n "$found" ] || { error "no .img in $img"; return 1; }
    mv "$found" "$out" && rm -Rf "$mtmp"
}

get_img_file() {
    local fout="" input="$1" output="$2" tempd="$3"
    fout=$(LANG=C file "$input") || { error "failed: file $input"; return 1; }
    case "${fout#$input: }" in
        "gzip compressed"*)
            fout=$(zcat "$input" | file -)
            case "${fout#*: }" in
                POSIX\ tar*) get_img_from_tar "$input" "$output" "$tempd";;
                *) zcat -c "$input" > "$output";;
            esac
            ;;
        "POSIX tar"*)
            get_img_from_tar "$input" "$output" "$tempd";;
        *) ln -s "$(readlink -f "$input")" "$output";
    esac
}

ensure_file_d() {
    local f="" d=""
    for f in "$@"; do
        d=$(dirname "$f")
        mkdir -p "$d" || return
    done
    return 0
}

main() {
    local short_opts="a:hk:p:v"
    local long_opts="arch:,help,kernel:,krd-pack:,no-gzip,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local cur="" next="" output="" gzip=true kpkg=""
    local kpacks="" src_in="" src="" arch="" vflags=""
    kpacks=( )

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
            -h|--help) Usage ; exit 0;;
            -a|--arch) arch="$next"; shift;;
            -k|--kernel) kpkg=$next; shift;;
            -p|--krd-pack) kpacks[${#kpacks[@]}]="$next"; shift;;
               --no-gzip) gzip=false;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1)); vflags="${vflags}v";;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 2 ] || { bad_Usage "must provide source and target"; return; }
    src_in="$1"
    output="$2"
    [ -z "$vflags" ] || vflags="-$vflags"

    PATH="$(dirname "$0"):$PATH"
    command -v "maas-cloudimg2ephemeral" >/dev/null 2>&1 ||
        { error "do not have maas-cloudimg2ephemeral in path"; return 1; }

    TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
        { error "failed to make tempdir"; return 1; }
    trap cleanup EXIT

    if [ -f "$src_in" ]; then
        src="$src_in"
    else
        case "$src_in" in
            http://*|https://*|ftp://*)
                src="${TEMP_D}/${src_in##*/}"
                wget "$src_in" --dot-style=mega -O "$src" ||
                    { error "failed download $src_in"; return 1; }
                ;;
            file://*)
                [ -f "${src_in#file://}" ] ||
                    { error "$src_in: not a file"; return 1; }
                src="${src_in#file://}"
                ;;
            *) error "Unable to handle src: $src_in"; return 1;;
        esac
    fi

    # now src is either a .tar.gz file, or a .img file
    local imgfile="${TEMP_D}/root.img"
    get_img_file "$src" "$imgfile" "${TEMP_D}" ||
        { error "failed to get image file from $src"; return 1; }

    if [ "$src" -ef "$imgfile" ]; then
        src="${TEMP_D}/src.img"
        rm -f "$imgfile"
        cp --sparse=always "$src_in" "$imgfile" ||
            { error "failed to copy $src_in to temp"; return 1; }
    fi

    ensure_file_d "$output" ||
        { error "failed to create dir for $output"; return 1; }

    # now imgfile has the root filesystem image to adjust
    local pkout="${TEMP_D}/$kpkg-kernel" piout="${TEMP_D}/$kpkg-initrd"
    local manif="${TEMP_D}/manifest"
    maas-cloudimg2ephemeral $vflags --zero \
        ${arch:+"--arch=$arch"} "$imgfile" \
        "$kpkg" "$pkout" "$piout" "$manifest" ||
        { error "failed to turn $imgfile to ephemeral"; return 1; }

    local i="" ckpkg="" ckout="" ciout="" subarch="" oifs="$IFS"
    for i in "${kpacks[@]}"; do
        IFS=","; set -- $i; IFS="$oifs"
        # tkout, tiout = target kernel out, target initrd out
        ckpkg="$1"; tkout="$2"; tiout="$3"
        shift 3
        flags=( "$@" )
        ckout="${TEMP_D}/$ckpkg-$subarch-kernel"
        ciout="${TEMP_D}/$ckpkg-$subarch-initrd"
        KPACK_SKIP_APT_UPDATE=true kpack-from-image "$imgfile" \
            "$ckpkg" "$ckout" "$ciout" "${flags[@]}" ||
            { error "failed to get $ckpkg output"; return 1; }
        ensure_file_d "$tkout" "$tiout" ||
            { error "failed to make dirs for $tkout or $tiout"; return 1; }
        mv "$ckout" "$tkout" &&
            mv "$ciout" "$tiout" ||
            { error "failed copying files"; return 1; }
    done

    if $gzip; then
        debug 1 "gzipping image file"
        local stime=$SECONDS
        gzip -9 --rsyncable "$imgfile" &&
            mv --force "$imgfile.gz" "$output" ||
            { error "failed gzip"; return 1; }
        debug 1 "gzip took $(($SECONDS-$stime))s"
    else
        mv --force "$imgfile" "$output" ||
            { error "failed move to $output"; return 1; }
    fi
    return 0
}

main "$@"
# vi: ts=4 expandtab
