#!/bin/bash

VERBOSITY=1
TEMP_D=""

error() { echo "$@" 1>&2; }
fail() { [ $# -eq 0 ] || error "$@"; exit 1; }

Usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] source-image output-image.gz

   convert 'source-image' into a ephemeral image and put
   output into output-image.gz.

   source-image can be url or file path that is either .tar.gz or .img.

   options:
         --no-gzip     do not gzip output image
    -k | --kernel K    keep/install the kernel package 'k' inside image
    -p | --krd-pack P  create a kernel / ramdisk pack
                       P is ',' delimited: kernel-name,kernel,ramdisk[,flags]
         --manifest M  write the dpkg manifest to M
    -v | --verbose     increase verbosity

   Example:
     ${0##*/} --kernel=linux-generic \\
        --krd-pack=linux-generic,output/kernel,output/initrd \\
        trusty-server-cloudimg-armhf.tar.gz \\
        output/root-image.gz
EOF
}

bad_Usage() { Usage 1>&2; [ $# -eq 0 ] || error "$@"; return 1; }
cleanup() {
    [ -z "${TEMP_D}" -o ! -d "${TEMP_D}" ] || rm -Rf "${TEMP_D}"
}

ddebug() {
    local level="$1"; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "$(date -R):" "$@"
}

debug() {
    local level=${1}; shift;
    [ "${level}" -gt "${VERBOSITY}" ] && return
    error "${@}"
}

get_img_from_tar() {
    local img="$1" out="$2" tempd="$3"
    local mtmp=$(mktemp -d "${tempd}/img_from_tar.XXXXXX")
    tar -C "$mtmp" -Sxf "$img" ||
        { error "failed to extract $img"; return 1; }
    local f="" found=""
    for f in "${mtmp}/"*; do
        [ ! -f "$f" -o "${f%.img}" = "$f" ] && continue
        [ -z "$found" ] ||
            { error "multiple .img found in $img"; return 1; }
        found="$f"
    done
    [ -n "$found" ] || { error "no .img in $img"; return 1; }
    mv "$found" "$out" && rm -Rf "$mtmp"
}

get_img_file() {
    local fout="" input="$1" output="$2" tempd="$3"
    fout=$(LANG=C file "$input") || { error "failed: file $input"; return 1; }
    case "${fout#$input: }" in
        "gzip compressed"*)
            fout=$(zcat "$input" | file -)
            case "${fout#*: }" in
                POSIX\ tar*) get_img_from_tar "$input" "$output" "$tempd";;
                *) zcat -c "$input" > "$output";;
            esac
            ;;
        "POSIX tar"*)
            get_img_from_tar "$input" "$output" "$tempd";;
        *ext[234]\ filesystem*)
            ln -s "$(readlink -f "$input")" "$output";;
        *)
            # if the above failed (on trusty a .tar.gz file was reported
            # as a Minux file system) then try filename based heuristics
            case "$input" in
                *.tar.gz|*.tgz|*.tar) 
                    debug 1 "guessing content is tar archive [$fout]"
                    get_img_from_tar "$input" "$output" "$tempd";;
                *.gz)
                    debug 1 "guessing content is gzip [$fout]"
                    zcat -c "$input" > "$output";;
                *) 
                    error "WARN: unknown file '$input'. Assuming mountable image"
                    error "file output: $fout"
                    ln -s "$(readlink -f "$input")" "$output";;
            esac
    esac
}

ensure_file_d() {
    local f="" d=""
    for f in "$@"; do
        d=$(dirname "$f")
        mkdir -p "$d" || return
    done
    return 0
}

human2bytes() {
    # converts size suitable for input to resize2fs to bytes
    # s:512 byte sectors, K:kilobytes, M:megabytes, G:gigabytes
    # none: block size of the image
    local input=${1} defunit=${2:-1024}
    local unit count;
    case "$input" in
        *s) count=${input%s}; unit=512;;
        *K) count=${input%K}; unit=1024;;
        *M) count=${input%M}; unit=$((1024*1024));;
        *G) count=${input%G}; unit=$((1024*1024*1024));;
        *)  count=${input}  ; unit=${defunit};;
    esac
   _RET=$((${count}*${unit}))
}

resize_image() {
    # set image size to 'size'
    #  if size is '+<size>', it will be grown by that size
    #  if '--allow-padding' provided, then size will be
    #    the minimum of "minimum_size + padding" or size
    local padding=""
    case "$1" in
        --allow-padding=*) padding="${1#--allow-padding=}"; shift;;
        --allow-padding) padding="$2"; shift 2;;
    esac
    local img="$1" size="$2" ret="" tok=":"
    local oimgsize="" oblocks="" out="" blksize=""
    local tbytes="" minblocks=""
    out=$(ls -l "$img") && oimgsize=$(echo "$out" | awk '{print $5}') &&
        [ -n "$oimgsize" ] ||
        { error "failed to get size of $img"; return 1; }

    case "$size" in
        +*) human2bytes "${size#+}" ||
                { error "failed convert '${size#+}' to bytes"; return 1; }
            tbytes=$(($oimgsize+$_RET))
            ;;
        *) human2bytes "$size" ||
                { error "failed convert '$size' to bytes"; return 1; }
            tbytes=${_RET}
            ;;
    esac

    if [ -n "$padding" ]; then
        human2bytes "$padding" || {
            error "failed convert '$padding' to bytes";
            return 1;
        }
        padbytes=$_RET
    fi

    out=$(e2fsck -fy "$img" 2>&1) ||
        { error "failed to e2fsck -fy '$img'"; error "$out"; return 1; }

    out=$(LC_ALL=C dumpe2fs "$img" 2>/dev/null) ||
        { error "failed 'dumpe2fs $img'"; return 1; }
    oblocks=$(printf "%s\n" "$out" |
        awk '$0 ~ /^Block count:/ { print $3 }') &&
        [ -n "$oblocks" ] || {
            error "failed to record blocks in $img"
            return
        }

    blksize=$(printf "%s\n" "$out" |
        awk '$0 ~ /^Block size:/ { print $3 }')

    out=$(LC_ALL=C resize2fs -P "$img" 2>/dev/null) ||
        { error "failed to get min image size"; return 1; }
    minblocks=$(printf "%s\n" "$out" | awk '$0 ~ /minimum/ { print $NF }')
    [ -n "$minblocks" ] ||
        { error "failed to get min blocks in '$img'"; return 1; }

    local tblocks=$(($tbytes/$blksize))
    local des_blocks=$tblocks
    if [ -n "$padding" ]; then
        if [ $(($minblocks+($padbytes/$blksize))) -gt $tblocks ]; then
            des_blocks=$((minblocks+($padbytes/$blksize)))
            error "WARN: '--allow-padding=$padding'."
            error "  minblocks=$minblocks target=$tblocks desired=$des_blocks"
        elif [ $((minblocks+$(($padbytes/$blksize)))) -lt $tblocks ]; then
            ddebug 1 "do not need pad, target=$tblocks > $minblocks+$padding"
        fi
    fi

    if [ $des_blocks -lt $minblocks ]; then
        error "target blocks '$tblocks' smaller than minblocks '$minblocks'"
        error "fail: Could reize to to $size."
        error "  minblocks=$minblocks target=$tblocks desired=$des_blocks"
        return 1
    fi
    tbytes=$(($des_blocks*$blksize))

    ddebug 1 "targetting $tbytes ($des_blocks*$blksize) bytes."
    ddebug 1 "fs is currently $oblocks * $blksize."
    ddebug 1 "resize to $des_blocks. minblocks=$minblocks. target=$tblocks"

    if [ "$oimgsize" -lt "$tbytes" ]; then
        truncate --size=$tbytes "$img" ||
            { error "failed to resize image to $tbytes"; return 1; }
    fi

    out=$(e2fsck -fy "$img" 2>&1) ||
        { error "failed to e2fsck -fy '$img'"; error "$out"; return 1; }

    out=$(resize2fs "$img" "$des_blocks" 2>&1) ||
        { error "failed resize '$img'"; error "$out"; return 1; }

    if [ "$oimgsize" -gt "$tbytes" ]; then
        truncate --size=$tbytes "$img"
    fi

    out=$(e2fsck -fy "$img" 2>&1) ||
        { error "failed to e2fsck -fy '$img'"; error "$out"; return 1; }

    _RET="$oimgsize:$oblocks"
}

allow_resize_failure() {
    local arch="$1" bdist="" barch=""
    barch=${2:-$(uname -m)}
    bdist=${3:-$(lsb_release -sc)}

    if [ "$arch" = "arm64" ] &&
       [ "$barch" = "x86_64" -o -z "${barch#i?86}" ] &&
       [ "$bdist" = "utopic" -o "$bdist" = "vivid" ]; then
        error "***************************"
        error "WARN: resize2fs fail allowed for arch=$arch on dist=$bdist/$barch"
        error "WARN: arm64 builds require utopic due to"
        error "      'qemu: uncaught target signal 11'"
        error "as seen http://tinyurl.com/koqo99m"
        error "        http://paste.ubuntu.com/9900803/"
        error ""
        error "resize2fs is broken on utopic: http://pad.lv/1415077"
        error "***************************"
        return 0
    else
        error "resize image failure not allowed for $arch/$barch/$bdist"
        return 1
    fi
}

handle_kpack() {
    local short_opts="v"
    local long_opts="dtb:,kihelper:"
    local getopt_out=""
    getopt_out=$(getopt --name "handle_kpack" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local dtbs pt img outd ckpkg tkout tiout
    dtbs=( )
    pt=( )
    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
               --dtb) dtbs[${#dtbs[@]}]="$next"; shift;;
               --kihelper) pt[${#pt[@]}]="$cur=$next"; shift;;
            --) shift; break;;
        esac
        shift;
    done
    # tkout, tiout = target kernel out, target initrd out
    img="$1"; ckpkg="$2"; tkout="$3"; tiout="$4"
    shift 4
    outd="${TEMP_D}/$ckpkg"
    mkdir -p "$outd" ||
        { error "failed tempdir for '$ckpkg'"; return 1; }

    local cmd=""
    cmd=( env KPACK_SKIP_APT_UPDATE=true kpack-from-image \
             $vflags "${pt[@]}" "$imgfile" "$ckpkg" "$outd" )
    ddebug 1 "$(date -R): starting ${cmd[*]}"
    "${cmd[@]}" ||
        { error "failed to get $ckpkg output"; return 1; }
    ensure_file_d "$tkout" "$tiout" ||
        { error "failed to make dirs for $tkout or $tiout"; return 1; }
    mv "$outd/kernel" "$tkout" &&
        mv "$outd/initrd" "$tiout" ||
        { error "failed copying files"; return 1; }

    local darg="" bname="" outf=""
    for darg in "${dtbs[@]}"; do
        # format is name=output. and kpack-from-image names
        # files dtb-<name>
        bname=${darg%%=*}
        outf=${darg#*=}
        ensure_file_d "$outf" || { error "failed mkdir for $outf"; return 1; }
        if [ -f "$outd/dtb-$bname" ]; then
            mv "$outd/dtb-$bname" "$outf" ||
                { error "failed moving dtb-$bname to $outf"; return 1; }
        elif [ -f "$outd/dtb-$bname.dtb" ]; then
            mv "$outd/dtb-$bname.dtb" "$outf" ||
                { error "failed moving dtb-$bname.dtb to $outf"; return 1; }
        else
            error "did not find dtb file $bname"
            return 1;
        fi
    done
}

main() {
    local short_opts="a:hk:p:v"
    local long_opts="arch:,help,kernel:,krd-pack:,manifest:,no-gzip,verbose"
    local getopt_out=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { bad_Usage; return; }

    local cur="" next="" output="" gzip=true kpkg=""
    local kpacks="" src_in="" src="" arch="" vflags=""
    local working_space="1024M" zero_img="true" fs_img_size="1400M"
    local manifest_out=""
    kpacks=( )

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
            -h|--help) Usage ; exit 0;;
            -a|--arch) arch="$next"; shift;;
            -k|--kernel) kpkg=$next; shift;;
               --manifest) manifest_out="$next";;
            -p|--krd-pack) kpacks[${#kpacks[@]}]="$next"; shift;;
               --no-gzip) gzip=false;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1)); vflags="${vflags}v";;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -eq 2 ] || { bad_Usage "must provide source and target"; return; }
    src_in="$1"
    output="$2"
    [ -z "$vflags" ] || vflags="-$vflags"

    PATH="$(dirname "$0"):$PATH"
    command -v "maas-cloudimg2ephemeral" >/dev/null 2>&1 ||
        { error "do not have maas-cloudimg2ephemeral in path"; return 1; }

    [ -z "$kpkg" ] && {
        error "no '--kernel' provided, choosing 'linux-generic'"
        kpkg="linux-generic"
    }

    TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
        { error "failed to make tempdir"; return 1; }
    trap cleanup EXIT

    if [ -f "$src_in" ]; then
        src="$src_in"
    else
        case "$src_in" in
            http://*|https://*|ftp://*)
                ddebug 1 "getting source $src_in"
                src="${TEMP_D}/${src_in##*/}"
                wget "$src_in" --dot-style=mega -O "$src" ||
                    { error "failed download $src_in"; return 1; }
                ;;
            file://*)
                [ -f "${src_in#file://}" ] ||
                    { error "$src_in: not a file"; return 1; }
                src="${src_in#file://}"
                ;;
            *) error "Unable to handle src: $src_in"; return 1;;
        esac
    fi

    # now src is either a .tar.gz file, or a .img file
    local imgfile="${TEMP_D}/root.img"
    ddebug 1 "getting .img from $src"
    get_img_file "$src" "$imgfile" "${TEMP_D}" ||
        { error "failed to get image file from $src"; return 1; }

    if [ "$src" -ef "$imgfile" ]; then
        rm -f "$imgfile"
        ddebug 1 "copying $src_in to $imgfile"
        cp --sparse=always "$src" "$imgfile" ||
            { error "failed to copy $src_in to temp"; return 1; }
    fi

    ensure_file_d "$output" ||
        { error "failed to create dir for $output"; return 1; }

    local restore_img_info=""
    if [ -n "$working_space" ]; then
        ddebug 1 "getting '$working_space' in $imgfile"
        resize_image "$imgfile" "+$working_space" ||
            { error "failed to grow $imgfile by $working_space"; return 1; }
        restore_img_info="$_RET"
    fi

    # now imgfile has the root filesystem image to adjust
    local pkout="${TEMP_D}/$kpkg-kernel" piout="${TEMP_D}/$kpkg-initrd"
    local manif="${TEMP_D}/manifest"
    local mc2ephem=""
    mc2ephem=( maas-cloudimg2ephemeral $vflags ${arch:+"--arch=$arch"}
               "$imgfile" "$kpkg" "$pkout" "$piout" "$manif" )
    ddebug 1 "starting ${mc2ephem[*]}"
    "${mc2ephem[@]}" ||
        { error "failed to turn $imgfile to ephemeral"; return 1; }
    [ -z "$manifest_out" ] || cp "$manif" "$manifest_out" ||
        { error "failed copying manifest to $manifest_out"; return 1; }

    local i="" oifs="$IFS"
    ddebug 1 "starting kpacks: ${kpacks[*]}"
    for i in "${kpacks[@]}"; do
        IFS=","; set -- $i; IFS="$oifs"
        handle_kpack "$imgfile" "$@" ||
            { error "handle_kpack '$imgfile' $* failed"; return 1; }
    done
    ddebug 1 "kpacks done"

    local padarg=""
    ## ppc64el wily do not fit in 1400M. Instead of allowing this across the
    ## board, we're going to keep the 1400M standard other places.
    ## the '--allow-padding=100M' should give you 100M of wiggle room in
    ## the resultant image.
    if [ "$arch" = "ppc64el" ]; then
        padarg="--allow-padding=100M"
    fi
    if [ -n "$fs_img_size" ]; then
        ddebug 1 "setting final image to $fs_img_size"
        if ! resize_image ${padarg} "$imgfile" "$fs_img_size"; then
            if ! allow_resize_failure "$arch"; then
                error "failed resize of $imgfile"
                return 1;
            fi
        fi
    fi

    if $zero_img; then
        ddebug 1 "zeroing img"
        e2fsck -fy "$imgfile" || { error "failed to e2fsck $imgfile"; return 1; }
        zerofree "$imgfile" || { error "failed zerofree $imgfile"; return 1; }
    fi

    if $gzip; then
        ddebug 1 "gzipping image file"
        local stime=$SECONDS
        gzip -9 --rsyncable "$imgfile" &&
            mv --force "$imgfile.gz" "$output" ||
            { error "failed gzip"; return 1; }
        ddebug 1 "gzip took $(($SECONDS-$stime))s"
    else
        mv --force "$imgfile" "$output" ||
            { error "failed move to $output"; return 1; }
    fi
    ddebug 1 "finished"
    return 0
}

main "$@"
# vi: ts=4 expandtab
