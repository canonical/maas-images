#!/usr/bin/python
#   Copyright (C) 2013 Canonical Ltd.
#
#   Author: Scott Moser <scott.moser@canonical.com>
#
#   Simplestreams is free software: you can redistribute it and/or modify it
#   under the terms of the GNU Affero General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   Simplestreams is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
#   License for more details.
#
#   You should have received a copy of the GNU Affero General Public License
#   along with Simplestreams.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import copy
import hashlib
import json
import os
import os.path
import sys

import simplestreams.util as sutil


MAAS_RDNS = "com.ubuntu.maas"
FILE_DATA = {}

DEF_TAGS = {'arch': 'NOARCH', 'release': 'NORELEASE', 'version': 'NOVERSION'}
DEF_EPH_ITEMS = ['boot-kernel', 'boot-initrd', 'root-image']
DEF_PATH_TEMPL = "%(release)s/%(arch)s/%(version_id)s/%(_subarch)s/%(item_id)s"
DEF_ROOTIMG_TEMPL = "%(release)s/%(arch)s/%(version_id)s/%(item_id)s"

BASE_ARCHES = ["armhf", "i386", "amd64"]

RELEASE_DATA = {
    'precise': {
        'version': "12.04", 'arches': BASE_ARCHES,
        'base_subarches': ["generic"],
        'hwes': [
            ('hwe-p', ["20120426", "20120824", "20130214", "20130823",
                       "20140206", "20140828"],),
            ('hwe-q', ["20130214", "20130823", "20140206", "20140828"],),
            ('hwe-r', ["20130823", "20140206", "20140828"],),
            ('hwe-s', ["20140206", "20140828"],),
            ('hwe-t', ["20140828"],),
        ],
    },
    'quantal': {
        'version': "12.10", 'arches': BASE_ARCHES,
        'base_subarches': ["generic", "hwe-p"],
        'hwes': [("hwe-q", ["20121018", "20130131", "20130404"]), ],
    },
    'raring':  {
        'version': "13.04", 'arches': BASE_ARCHES,
        'base_subarches': ["generic", "hwe-p", "hwe-q"],
        'hwes': [("hwe-r", ["20130425", "20130630", "20130920"]), ],
    },
    'saucy':   {
        'version': "13.10", 'arches': BASE_ARCHES,
        'base_subarches': ["generic", "hwe-p", "hwe-q", "hwe-r"],
        'hwes': [("hwe-s", ["20131017", "20140122", "20140323"]), ],
    },
    'trusty':  {
        'version': "14.04", 'arches': BASE_ARCHES + ['ppc64el'],
        'base_subarches': ["generic", "hwe-p", "hwe-q", "hwe-r", "hwe-s"],
        'hwes': [('hwe-t', ["20140417", "20140508"],), ],
    },
}

# we just make the d-i kernels one day earlier
DI_DATA = copy.deepcopy(RELEASE_DATA)
for _r in DI_DATA:
    _t = []
    for hwe, vlist in DI_DATA[_r]['hwes']:
        _t.append((hwe, [str(int(v)-1) for v in vlist],))
    DI_DATA[_r]['hwes'] = _t


def get_checksums(inputstr):
    ret = {}
    for h in ('md5', 'sha256'):
        hl = hashlib.new(h)
        hl.update(inputstr)
        ret[h] = hl.hexdigest()
    return ret


def get_filedata(path, buflen=1024):
    checksums = ('md5', 'sha256')
    hashers = {h: hashlib.new(h) for h in checksums}
    ret = {'size': 0}

    with open(path, "r") as fp:
        blen = buflen
        while blen == buflen:
            buf = fp.read(buflen)
            blen = len(buf)
            ret['size'] += blen
            for h in hashers:
                hashers[h].update(buf)

    ret.update({h: hashers[h].hexdigest() for h in checksums})
    return ret


def mkdir_p(path):
    if os.path.exists(path):
        return
    os.makedirs(path)


def makedata_filepath(target, item):
    with open(target, "w") as fp:
        fp.write(item['path'] + "\n")


class FakeProduct(object):
    def __init__(self, product_id, versions=None, tags=None, items=None,
                 templs=None):
        self.product_id = product_id
        if versions is None:
            versions = []
        if tags is None:
            tags = DEF_TAGS.copy()
        if items is None:
            items = [f for f in DEF_EPH_ITEMS]
        if templs is None:
            templs = {'default': DEF_PATH_TEMPL,
                      'root-image': DEF_ROOTIMG_TEMPL}
        self.versions = versions
        self.templs = templs
        self.tags = tags
        self.items = items
        self._versions = {}
        for v in versions:
            self.makeitems(v)

    def get_path_templ(self, version, item):
        return self.templs.get(item, self.templs.get('default'))

    def makeitems(self, version):
        d = {}
        for item in self.items:
            d[item] = {}
            subst = self.tags.copy()
            subst.update({'item_id': item, 'version_id': version})
            path = self.get_path_templ(version, item) % subst
            d[item] = {'path': path, 'ftype': item}
        self._versions[version] = d

    def makepaths(self, target, makedata=makedata_filepath):
        for version_id, ver in self._versions.items():
            for item_id, item in ver.items():
                tfile = os.path.join(target, item['path'])
                if not os.path.exists(tfile):
                    mkdir_p(os.path.dirname(tfile))
                    makedata(tfile, item)
                item.update(get_filedata(tfile))

    def asproduct(self):
        t = {self.product_id: {}}
        t[self.product_id]['versions'] = self._versions.copy()
        t[self.product_id].update({k: v for k, v in self.tags.items()
                                   if not k.startswith("_")})
        return t


def get_products(pid_pre, release, data, items=None):
    products = []
    for arch in data.get('arches', BASE_ARCHES):
        subarches = [s for s in data['base_subarches']]
        for hwe, versions in data['hwes']:
            subarches.append(hwe)
            pid = ':'.join((pid_pre, data['version'], arch, hwe,))
            myp = FakeProduct(
                product_id=pid, versions=versions, items=items,
                tags={'release': release, 'version': data['version'],
                      'arch': arch, 'subarches': ",".join(subarches),
                      '_subarch': hwe})
        products.append(myp)
    return products


def create_index(target_d, files=None, path_prefix="streams/v1/"):
    if files is None:
        files = [f for f in os.listdir(target_d) if f.endswith(".json")]

    ret = {'index': {}, 'format': 'index:1.0', 'updated': sutil.timestamp()}
    for f in files:
        with open(os.path.join(target_d, f), "r") as fp:
            data = sutil.load_content(fp.read())
        fmt = data.get('format')
        cid = data.get('content_id')
        if fmt == "index:1.0" or not (fmt and cid):
            continue
        optcopy = ('datatype', 'updated', 'format')
        item = {k: data.get(k) for k in optcopy if data.get(k)}
        if data.get('format') == "products:1.0":
            item['products'] = [p for p in data['products'].keys()]

        item['path'] = path_prefix + f

        ret['index'][cid] = item

    return ret


def main():
    parser = argparse.ArgumentParser(description="create example content tree")

    parser.add_argument("out_d", metavar='out_d',
                        help=('create content under output_dir'))

    parser.add_argument('--sign', action='store_true', default=False,
                        help='sign all generated files')

    args = parser.parse_args()

    products = []

    pid_pre = MAAS_RDNS + ":boot:boot-ephem"
    for release, data in RELEASE_DATA.iteritems():
        tprod = get_products(pid_pre=pid_pre, release=release,
                             data=data)
        products += tprod

    pid_pre = MAAS_RDNS + "boot:di-netboot"
    for release, data in DI_DATA.iteritems():
        tprod = get_products(pid_pre=pid_pre, release=release,
                             data=data, items=['di-kernel', 'di-initrd'])
        products += tprod

    content = {
        'datatype': 'image-downloads',
        'format': 'products:1.0',
        'content_id': MAAS_RDNS + ":boot",
        'updated': sutil.timestamp(),
        'products': {}
    }
    for product in products:
        product.makepaths(args.out_d)
        t = product.asproduct()
        content['products'][product.product_id] = t[product.product_id]

    sutil.products_condense(content)
    v1dir = os.path.join(args.out_d, 'streams', 'v1')
    cpath = os.path.join(v1dir, content['content_id'])
    ipath = os.path.join(v1dir, 'index.json')
    cpath += ".json"
    mkdir_p(os.path.dirname(cpath))
    with open(cpath, "w") as fp:
        fp.write(sutil.dump_data(content))

    index = create_index(v1dir)
    with open(ipath, "w") as fp:
        fp.write(sutil.dump_data(index))

if __name__ == '__main__':
    sys.exit(main())

# vi: ts=4 expandtab
