#!/usr/bin/python
#   Copyright (C) 2013 Canonical Ltd.
#
#   Author: Scott Moser <scott.moser@canonical.com>
#
#   Simplestreams is free software: you can redistribute it and/or modify it
#   under the terms of the GNU Affero General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   Simplestreams is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
#   License for more details.
#
#   You should have received a copy of the GNU Affero General Public License
#   along with Simplestreams.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import hashlib
import json
import os
import os.path
import sys


MAAS_RDNS = "com.ubuntu.maas"
FILE_DATA = {}

DEF_TAGS = {'arch': 'NOARCH', 'release': 'NORELEASE', 'version': 'NOVERSION'}
DEF_EPH_ITEMS = ['boot-kernel', 'boot-initrd', 'root-image']
DEF_PATH_TEMPL = "%(release)s/%(arch)s/%(version_id)s/%(_subarch)s/%(item_id)s"
DEF_ROOTIMG_TEMPL = "%(release)s/%(arch)s/%(version_id)s/%(item_id)s"

VERSIONS = {
    'p-hwe-p': ["20120426", "20120824", "20130214", "20130823", "20140206",
                "20140828"],
    'p-hwe-q': ["20130214", "20130823", "20140206", "20140828"],
    'p-hwe-r': ["20130823", "20140206", "20140828"],
    'p-hwe-s': ["20140206", "20140828"],
    'p-hwe-t': ["20140828"],
}
NONLTS = {
    'quantal': {'version': "12.10",
                'subarches': ["generic", "hwe-p", "hwe-q"],
                'versions': ["20121018", "20130131", "20130404"],
                'subarch': "hwe-q"},
    'raring': {'version': "13.04",
               'subarches': ["generic", "hwe-p", "hwe-q", "hwe-r"],
               'versions': ["20130425", "20130630", "20130920"],
               'subarch': "hwe-r"},
    'saucy': {'version': "13.10",
              'subarches': ["generic", "hwe-p", "hwe-q", "hwe-r", "hwe-s"],
              'versions': ["20131017", "20140122", "20140323"],
              'subarch': "hwe-s"},
}


def get_checksums(inputstr):
    ret = {}
    for h in ('md5', 'sha256'):
        hl = hashlib.new(h)
        hl.update(inputstr)
        ret[h] = hl.hexdigest()
    return ret


def get_filedata(path, buflen=1024):
    checksums = ('md5', 'sha256')
    hashers = {h: hashlib.new(h) for h in checksums}
    ret = {'size': 0}

    with open(path, "r") as fp:
            
        blen = buflen
        while blen == buflen:
            buf = fp.read(buflen)
            blen = len(buf)
            ret['size'] += blen
            for h in hashers:
                hashers[h].update(buf)

    ret.update({h: hashers[h].hexdigest() for h in checksums})
    return ret


def mkdir_p(path):
    if os.path.exists(path):
        return
    os.makedirs(path)


def makedata_filepath(target, item):
    with open(target, "w") as fp:
        fp.write(item['path'] + "\n")


class FakeProduct(object):
    def __init__(self, product_id, versions=None, tags=None, items=None,
                 templs=None):
        self.product_id = product_id
        if versions is None:
            versions = []
        if tags is None:
            tags = DEF_TAGS.copy()
        if items is None:
            items = [f for f in DEF_EPH_ITEMS]
        if templs is None:
            templs = {'default': DEF_PATH_TEMPL,
                      'root-image': DEF_ROOTIMG_TEMPL}
        self.versions = versions
        self.templs = templs
        self.tags = tags
        self.items = items
        self._versions = {}
        for v in versions:
            self.makeitems(v)

    def get_path_templ(self, version, item):
        return self.templs.get(item, self.templs.get('default'))

    def makeitems(self, version):
        d = {}
        for item in self.items:
            d[item] = {}
            subst = self.tags.copy()
            subst.update({'item_id': item, 'version_id': version})
            path = self.get_path_templ(version, item) % subst
            d[item] = {'path': path, 'ftype': item}
        self._versions[version] = d

    def makepaths(self, target, makedata=makedata_filepath):
        for version_id, ver in self._versions.items():
            for item_id, item in ver.items():
                tfile = os.path.join(target, item['path'])
                if not os.path.exists(tfile):
                    mkdir_p(os.path.dirname(tfile))
                    makedata(tfile, item)
                item.update(get_filedata(tfile))

    def asproduct(self):
        t = {self.product_id: {}}
        t[self.product_id]['versions'] = self._versions.copy()
        t[self.product_id].update({k: v for k, v in self.tags.items()
                                   if not k.startswith("_")})
        return t


def main():
    parser = argparse.ArgumentParser(description="create example content tree")

    parser.add_argument("out_d", metavar='out_d',
                        help=('create content under output_dir'))

    parser.add_argument('--sign', action='store_true', default=False,
                        help='sign all generated files')

    args = parser.parse_args()

    products = []
    pid_pre = MAAS_RDNS + ":boot-ephem"
    for arch in ("armhf", "i386", "amd64"):
        subarches = ["generic"]
        version = "12.04"
        for subarch in ("hwe-p", "hwe-q", "hwe-r", "hwe-s", "hwe-t"):
            subarches.append(subarch)
            pid = ':'.join((pid_pre, version, arch, subarch,))
            myp = FakeProduct(
                product_id=pid, versions=VERSIONS["p-" + subarch],
                tags={'release': "precise", 'version': version, 'arch': arch,
                      'subarches': ",".join(subarches), "_subarch": subarch})
            products.append(myp)

    for release, data in NONLTS.iteritems():
        for arch in data.get('arches', ("armhf", "i386", "amd64")):
            pid = ':'.join((pid_pre, data['version'], arch, subarch,))
            myp = FakeProduct(
                product_id=pid, versions=data['versions'],
                tags={'release': release, 'version': data['version'],
                      'arch': arch, 'subarches': ",".join(data['subarches']),
                      '_subarch': subarch})
        products.append(myp)

    pid_pre = ':'.join((MAAS_RDNS, 'di-netboot',))
    items = ['di-kernel', 'di-initrd']
    for arch in ("armhf", "i386", "amd64"):
        subarches = ["generic"]
        version = "12.04"
        for subarch in ("hwe-p", "hwe-q", "hwe-r", "hwe-s", "hwe-t"):
            subarches.append(subarch)
            pid = ':'.join((pid_pre, version, arch, subarch,))
            myp = FakeProduct(
                product_id=pid,
                versions=[str(int(v) - 1) for v in VERSIONS["p-" + subarch]],
                tags={'release': "precise", 'version': version, 'arch': arch,
                      'subarches': ",".join(subarches), "_subarch": subarch},
                items=items)
            products.append(myp)

    for product in products:
        product.makepaths(args.out_d)
        print json.dumps(product.asproduct(), indent=1)

if __name__ == '__main__':
    sys.exit(main())

# vi: ts=4 expandtab
